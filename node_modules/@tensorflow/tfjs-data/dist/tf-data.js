/**
 * @license
 * Copyright 2019 Google LLC. All Rights Reserved.
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * =============================================================================
 */
(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@tensorflow/tfjs-core')) :
    typeof define === 'function' && define.amd ? define(['exports', '@tensorflow/tfjs-core'], factory) :
    (factory((global.tf = global.tf || {}, global.tf.data = global.tf.data || {}),global.tf));
}(this, (function (exports,tf) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation. All rights reserved.
    Licensed under the Apache License, Version 2.0 (the "License"); you may not use
    this file except in compliance with the License. You may obtain a copy of the
    License at http://www.apache.org/licenses/LICENSE-2.0

    THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
    KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
    WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
    MERCHANTABLITY OR NON-INFRINGEMENT.

    See the Apache Version 2.0 License for specific language governing permissions
    and limitations under the License.
    ***************************************************************************** */
    /* global Reflect, Promise */

    var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };

    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }

    function __awaiter(thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }

    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    }

    var commonjsGlobal = typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

    function unwrapExports (x) {
    	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
    }

    function createCommonjsModule(fn, module) {
    	return module = { exports: {} }, fn(module, module.exports), module.exports;
    }

    var alea = createCommonjsModule(function (module) {
    // A port of an algorithm by Johannes Baagøe <baagoe@baagoe.com>, 2010
    // http://baagoe.com/en/RandomMusings/javascript/
    // https://github.com/nquinlan/better-random-numbers-for-javascript-mirror
    // Original work is under MIT license -

    // Copyright (C) 2010 by Johannes Baagøe <baagoe@baagoe.org>
    //
    // Permission is hereby granted, free of charge, to any person obtaining a copy
    // of this software and associated documentation files (the "Software"), to deal
    // in the Software without restriction, including without limitation the rights
    // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    // copies of the Software, and to permit persons to whom the Software is
    // furnished to do so, subject to the following conditions:
    // 
    // The above copyright notice and this permission notice shall be included in
    // all copies or substantial portions of the Software.
    // 
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    // AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    // LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    // OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
    // THE SOFTWARE.



    (function(global, module, define) {

    function Alea(seed) {
      var me = this, mash = Mash();

      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 2.3283064365386963e-10; // 2^-32
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };

      // Apply the seeding algorithm from Baagoe.
      me.c = 1;
      me.s0 = mash(' ');
      me.s1 = mash(' ');
      me.s2 = mash(' ');
      me.s0 -= mash(seed);
      if (me.s0 < 0) { me.s0 += 1; }
      me.s1 -= mash(seed);
      if (me.s1 < 0) { me.s1 += 1; }
      me.s2 -= mash(seed);
      if (me.s2 < 0) { me.s2 += 1; }
      mash = null;
    }

    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }

    function impl(seed, opts) {
      var xg = new Alea(seed),
          state = opts && opts.state,
          prng = xg.next;
      prng.int32 = function() { return (xg.next() * 0x100000000) | 0; };
      prng.double = function() {
        return prng() + (prng() * 0x200000 | 0) * 1.1102230246251565e-16; // 2^-53
      };
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    function Mash() {
      var n = 0xefc8249d;

      var mash = function(data) {
        data = data.toString();
        for (var i = 0; i < data.length; i++) {
          n += data.charCodeAt(i);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 0x100000000; // 2^32
        }
        return (n >>> 0) * 2.3283064365386963e-10; // 2^-32
      };

      return mash;
    }


    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.alea = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function' && undefined   // present with an AMD loader
    );
    });

    var xor128 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xor128" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;

      // Set up generator function.
      me.next = function() {
        var t = me.x ^ (me.x << 11);
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= (me.w >>> 19) ^ t ^ (t >>> 8);
      };

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor128 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function' && undefined   // present with an AMD loader
    );
    });

    var xorwow = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorwow" prng algorithm by
    // George Marsaglia.  See http://www.jstatsoft.org/v08/i14/paper

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var t = (me.x ^ (me.x >>> 2));
        me.x = me.y; me.y = me.z; me.z = me.w; me.w = me.v;
        return (me.d = (me.d + 362437 | 0)) +
           (me.v = (me.v ^ (me.v << 4)) ^ (t ^ (t << 1))) | 0;
      };

      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;

      if (seed === (seed | 0)) {
        // Integer seed.
        me.x = seed;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }

    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }

    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorwow = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function' && undefined   // present with an AMD loader
    );
    });

    var xorshift7 = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "xorshift7" algorithm by
    // François Panneton and Pierre L'ecuyer:
    // "On the Xorgshift Random Number Generators"
    // http://saluc.engr.uconn.edu/refs/crypto/rng/panneton05onthexorshift.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        // Update xor generator.
        var X = me.x, i = me.i, t, v;
        t = X[i]; t ^= (t >>> 7); v = t ^ (t << 24);
        t = X[(i + 1) & 7]; v ^= t ^ (t >>> 10);
        t = X[(i + 3) & 7]; v ^= t ^ (t >>> 3);
        t = X[(i + 4) & 7]; v ^= t ^ (t << 7);
        t = X[(i + 7) & 7]; t = t ^ (t << 13); v ^= t ^ (t << 9);
        X[i] = v;
        me.i = (i + 1) & 7;
        return v;
      };

      function init(me, seed) {
        var j, w, X = [];

        if (seed === (seed | 0)) {
          // Seed state array using a 32-bit integer.
          w = X[0] = seed;
        } else {
          // Seed state using a string.
          seed = '' + seed;
          for (j = 0; j < seed.length; ++j) {
            X[j & 7] = (X[j & 7] << 15) ^
                (seed.charCodeAt(j) + X[(j + 1) & 7] << 13);
          }
        }
        // Enforce an array length of 8, not all zeroes.
        while (X.length < 8) X.push(0);
        for (j = 0; j < 8 && X[j] === 0; ++j);
        if (j == 8) w = X[7] = -1; else w = X[j];

        me.x = X;
        me.i = 0;

        // Discard an initial 256 values.
        for (j = 256; j > 0; --j) {
          me.next();
        }
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }

    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xorshift7 = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function' && undefined   // present with an AMD loader
    );
    });

    var xor4096 = createCommonjsModule(function (module) {
    // A Javascript implementaion of Richard Brent's Xorgens xor4096 algorithm.
    //
    // This fast non-cryptographic random number generator is designed for
    // use in Monte-Carlo algorithms. It combines a long-period xorshift
    // generator with a Weyl generator, and it passes all common batteries
    // of stasticial tests for randomness while consuming only a few nanoseconds
    // for each prng generated.  For background on the generator, see Brent's
    // paper: "Some long-period random number generators using shifts and xors."
    // http://arxiv.org/pdf/1004.3115v1.pdf
    //
    // Usage:
    //
    // var xor4096 = require('xor4096');
    // random = xor4096(1);                        // Seed with int32 or string.
    // assert.equal(random(), 0.1520436450538547); // (0, 1) range, 53 bits.
    // assert.equal(random.int32(), 1806534897);   // signed int32, 32 bits.
    //
    // For nonzero numeric keys, this impelementation provides a sequence
    // identical to that by Brent's xorgens 3 implementaion in C.  This
    // implementation also provides for initalizing the generator with
    // string seeds, or for saving and restoring the state of the generator.
    //
    // On Chrome, this prng benchmarks about 2.1 times slower than
    // Javascript's built-in Math.random().

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this;

      // Set up generator function.
      me.next = function() {
        var w = me.w,
            X = me.X, i = me.i, t, v;
        // Update Weyl generator.
        me.w = w = (w + 0x61c88647) | 0;
        // Update xor generator.
        v = X[(i + 34) & 127];
        t = X[i = ((i + 1) & 127)];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        // Update Xor generator array state.
        v = X[i] = v ^ t;
        me.i = i;
        // Result is the combination.
        return (v + (w ^ (w >>> 16))) | 0;
      };

      function init(me, seed) {
        var t, v, i, j, w, X = [], limit = 128;
        if (seed === (seed | 0)) {
          // Numeric seeds initialize v, which is used to generates X.
          v = seed;
          seed = null;
        } else {
          // String seeds are mixed into v and X one character at a time.
          seed = seed + '\0';
          v = 0;
          limit = Math.max(limit, seed.length);
        }
        // Initialize circular array and weyl value.
        for (i = 0, j = -32; j < limit; ++j) {
          // Put the unicode characters into the array, and shuffle them.
          if (seed) v ^= seed.charCodeAt((j + 32) % seed.length);
          // After 32 shuffles, take v as the starting w value.
          if (j === 0) w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = (w + 0x61c88647) | 0;     // Weyl.
            t = (X[j & 127] ^= (v + w));  // Combine xor and weyl to init array.
            i = (0 == t) ? i + 1 : 0;     // Count zeroes.
          }
        }
        // We have detected all zeroes; make the key nonzero.
        if (i >= 128) {
          X[(seed && seed.length || 0) & 127] = -1;
        }
        // Run the generator 512 times to further mix the state before using it.
        // Factoring this as a function slows the main generator, so it is just
        // unrolled here.  The weyl generator is not advanced while warming up.
        i = 127;
        for (j = 4 * 128; j > 0; --j) {
          v = X[(i + 34) & 127];
          t = X[i = ((i + 1) & 127)];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i] = v ^ t;
        }
        // Storing state as object members is faster than using closure variables.
        me.w = w;
        me.X = X;
        me.i = i;
      }

      init(me, seed);
    }

    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null) seed = +(new Date);
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X) copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.xor4096 = impl;
    }

    })(
      commonjsGlobal,                                     // window object or global
      module,    // present in node.js
      (typeof undefined) == 'function' && undefined   // present with an AMD loader
    );
    });

    var tychei = createCommonjsModule(function (module) {
    // A Javascript implementaion of the "Tyche-i" prng algorithm by
    // Samuel Neves and Filipe Araujo.
    // See https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf

    (function(global, module, define) {

    function XorGen(seed) {
      var me = this, strseed = '';

      // Set up generator function.
      me.next = function() {
        var b = me.b, c = me.c, d = me.d, a = me.a;
        b = (b << 25) ^ (b >>> 7) ^ c;
        c = (c - d) | 0;
        d = (d << 24) ^ (d >>> 8) ^ a;
        a = (a - b) | 0;
        me.b = b = (b << 20) ^ (b >>> 12) ^ c;
        me.c = c = (c - d) | 0;
        me.d = (d << 16) ^ (c >>> 16) ^ a;
        return me.a = (a - b) | 0;
      };

      /* The following is non-inverted tyche, which has better internal
       * bit diffusion, but which is about 25% slower than tyche-i in JS.
      me.next = function() {
        var a = me.a, b = me.b, c = me.c, d = me.d;
        a = (me.a + me.b | 0) >>> 0;
        d = me.d ^ a; d = d << 16 ^ d >>> 16;
        c = me.c + d | 0;
        b = me.b ^ c; b = b << 12 ^ d >>> 20;
        me.a = a = a + b | 0;
        d = d ^ a; me.d = d = d << 8 ^ d >>> 24;
        me.c = c = c + d | 0;
        b = b ^ c;
        return me.b = (b << 7 ^ b >>> 25);
      }
      */

      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;

      if (seed === Math.floor(seed)) {
        // Integer seed.
        me.a = (seed / 0x100000000) | 0;
        me.b = seed | 0;
      } else {
        // String seed.
        strseed += seed;
      }

      // Mix in string seed, then discard an initial batch of 64 values.
      for (var k = 0; k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }

    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed),
          state = opts && opts.state,
          prng = function() { return (xg.next() >>> 0) / 0x100000000; };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11,
              bot = (xg.next() >>> 0) / 0x100000000,
              result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof(state) == 'object') copy(state, xg);
        prng.state = function() { return copy(xg, {}); };
      }
      return prng;
    }

    if (module && module.exports) {
      module.exports = impl;
    } else if (define && define.amd) {
      define(function() { return impl; });
    } else {
      this.tychei = impl;
    }

    })(
      commonjsGlobal,
      module,    // present in node.js
      (typeof undefined) == 'function' && undefined   // present with an AMD loader
    );
    });

    var seedrandom = createCommonjsModule(function (module) {
    /*
    Copyright 2014 David Bau.

    Permission is hereby granted, free of charge, to any person obtaining
    a copy of this software and associated documentation files (the
    "Software"), to deal in the Software without restriction, including
    without limitation the rights to use, copy, modify, merge, publish,
    distribute, sublicense, and/or sell copies of the Software, and to
    permit persons to whom the Software is furnished to do so, subject to
    the following conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
    IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY
    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

    */

    (function (pool, math) {
    //
    // The following constants are related to IEEE 754 limits.
    //

    // Detect the global object, even if operating in strict mode.
    // http://stackoverflow.com/a/14387057/265298
    var global = (0, eval)('this'),
        width = 256,        // each RC4 output is 0 <= x < 256
        chunks = 6,         // at least six RC4 outputs for each double
        digits = 52,        // there are 52 significant digits in a double
        rngname = 'random', // rngname: name for Math.random and Math.seedrandom
        startdenom = math.pow(width, chunks),
        significance = math.pow(2, digits),
        overflow = significance * 2,
        mask = width - 1,
        nodecrypto;         // node.js crypto module, initialized at the bottom.

    //
    // seedrandom()
    // This is the seedrandom function described above.
    //
    function seedrandom(seed, options, callback) {
      var key = [];
      options = (options == true) ? { entropy: true } : (options || {});

      // Flatten the seed string or build one from local entropy if needed.
      var shortseed = mixkey(flatten(
        options.entropy ? [seed, tostring(pool)] :
        (seed == null) ? autoseed() : seed, 3), key);

      // Use the seed to initialize an ARC4 generator.
      var arc4 = new ARC4(key);

      // This function returns a random double in [0, 1) that contains
      // randomness in every bit of the mantissa of the IEEE 754 value.
      var prng = function() {
        var n = arc4.g(chunks),             // Start with a numerator n < 2 ^ 48
            d = startdenom,                 //   and denominator d = 2 ^ 48.
            x = 0;                          //   and no 'extra last byte'.
        while (n < significance) {          // Fill up all significant digits by
          n = (n + x) * width;              //   shifting numerator and
          d *= width;                       //   denominator and generating a
          x = arc4.g(1);                    //   new least-significant-byte.
        }
        while (n >= overflow) {             // To avoid rounding up, before adding
          n /= 2;                           //   last byte, shift everything
          d /= 2;                           //   right using integer math until
          x >>>= 1;                         //   we have exactly the desired bits.
        }
        return (n + x) / d;                 // Form the number within [0, 1).
      };

      prng.int32 = function() { return arc4.g(4) | 0; };
      prng.quick = function() { return arc4.g(4) / 0x100000000; };
      prng.double = prng;

      // Mix the randomness into accumulated entropy.
      mixkey(tostring(arc4.S), pool);

      // Calling convention: what to return as a function of prng, seed, is_math.
      return (options.pass || callback ||
          function(prng, seed, is_math_call, state) {
            if (state) {
              // Load the arc4 state from the given state if it has an S array.
              if (state.S) { copy(state, arc4); }
              // Only provide the .state method if requested via options.state.
              prng.state = function() { return copy(arc4, {}); };
            }

            // If called as a method of Math (Math.seedrandom()), mutate
            // Math.random because that is how seedrandom.js has worked since v1.0.
            if (is_math_call) { math[rngname] = prng; return seed; }

            // Otherwise, it is a newer calling convention, so return the
            // prng directly.
            else return prng;
          })(
      prng,
      shortseed,
      'global' in options ? options.global : (this == math),
      options.state);
    }
    math['seed' + rngname] = seedrandom;

    //
    // ARC4
    //
    // An ARC4 implementation.  The constructor takes a key in the form of
    // an array of at most (width) integers that should be 0 <= x < (width).
    //
    // The g(count) method returns a pseudorandom integer that concatenates
    // the next (count) outputs from ARC4.  Its return value is a number x
    // that is in the range 0 <= x < (width ^ count).
    //
    function ARC4(key) {
      var t, keylen = key.length,
          me = this, i = 0, j = me.i = me.j = 0, s = me.S = [];

      // The empty key [] is treated as [0].
      if (!keylen) { key = [keylen++]; }

      // Set up S using the standard key scheduling algorithm.
      while (i < width) {
        s[i] = i++;
      }
      for (i = 0; i < width; i++) {
        s[i] = s[j = mask & (j + key[i % keylen] + (t = s[i]))];
        s[j] = t;
      }

      // The "g" method returns the next (count) outputs as one number.
      (me.g = function(count) {
        // Using instance members instead of closure state nearly doubles speed.
        var t, r = 0,
            i = me.i, j = me.j, s = me.S;
        while (count--) {
          t = s[i = mask & (i + 1)];
          r = r * width + s[mask & ((s[i] = s[j = mask & (j + t)]) + (s[j] = t))];
        }
        me.i = i; me.j = j;
        return r;
        // For robust unpredictability, the function call below automatically
        // discards an initial batch of values.  This is called RC4-drop[256].
        // See http://google.com/search?q=rsa+fluhrer+response&btnI
      })(width);
    }

    //
    // copy()
    // Copies internal state of ARC4 to or from a plain object.
    //
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    //
    // flatten()
    // Converts an object tree to nested arrays of strings.
    //
    function flatten(obj, depth) {
      var result = [], typ = (typeof obj), prop;
      if (depth && typ == 'object') {
        for (prop in obj) {
          try { result.push(flatten(obj[prop], depth - 1)); } catch (e) {}
        }
      }
      return (result.length ? result : typ == 'string' ? obj : obj + '\0');
    }

    //
    // mixkey()
    // Mixes a string seed into a key that is an array of integers, and
    // returns a shortened string seed that is equivalent to the result key.
    //
    function mixkey(seed, key) {
      var stringseed = seed + '', smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] =
          mask & ((smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++));
      }
      return tostring(key);
    }

    //
    // autoseed()
    // Returns an object for autoseeding, using window.crypto and Node crypto
    // module if available.
    //
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          // The use of 'out' to remember randomBytes makes tight minified code.
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global.crypto || global.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e) {
        var browser = global.navigator,
            plugins = browser && browser.plugins;
        return [+new Date, global, plugins, global.screen, tostring(pool)];
      }
    }

    //
    // tostring()
    // Converts an array of charcodes to a string
    //
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }

    //
    // When seedrandom.js is loaded, we immediately mix a few bits
    // from the built-in RNG into the entropy pool.  Because we do
    // not want to interfere with deterministic PRNG state later,
    // seedrandom will not call math.random on its own again after
    // initialization.
    //
    mixkey(math.random(), pool);

    //
    // Nodejs and AMD support: export the implementation as a module using
    // either convention.
    //
    if (module.exports) {
      module.exports = seedrandom;
      // When in node.js, try using crypto package for autoseeding.
      try {
        nodecrypto = require('crypto');
      } catch (ex) {}
    } else if ((typeof undefined) == 'function' && undefined.amd) {
      undefined(function() { return seedrandom; });
    }

    // End anonymous scope, and pass initial values.
    })(
      [],     // pool: entropy pool starts empty
      Math    // math: package containing random, pow, and seedrandom
    );
    });

    // A library of seedable RNGs implemented in Javascript.
    //
    // Usage:
    //
    // var seedrandom = require('seedrandom');
    // var random = seedrandom(1); // or any seed.
    // var x = random();       // 0 <= x < 1.  Every bit is random.
    // var x = random.quick(); // 0 <= x < 1.  32 bits of randomness.

    // alea, a 53-bit multiply-with-carry generator by Johannes Baagøe.
    // Period: ~2^116
    // Reported to pass all BigCrush tests.


    // xor128, a pure xor-shift generator by George Marsaglia.
    // Period: 2^128-1.
    // Reported to fail: MatrixRank and LinearComp.


    // xorwow, George Marsaglia's 160-bit xor-shift combined plus weyl.
    // Period: 2^192-2^32
    // Reported to fail: CollisionOver, SimpPoker, and LinearComp.


    // xorshift7, by François Panneton and Pierre L'ecuyer, takes
    // a different approach: it adds robustness by allowing more shifts
    // than Marsaglia's original three.  It is a 7-shift generator
    // with 256 bits, that passes BigCrush with no systmatic failures.
    // Period 2^256-1.
    // No systematic BigCrush failures reported.


    // xor4096, by Richard Brent, is a 4096-bit xor-shift with a
    // very long period that also adds a Weyl generator. It also passes
    // BigCrush with no systematic failures.  Its long period may
    // be useful if you have many generators and need to avoid
    // collisions.
    // Period: 2^4128-2^32.
    // No systematic BigCrush failures reported.


    // Tyche-i, by Samuel Neves and Filipe Araujo, is a bit-shifting random
    // number generator derived from ChaCha, a modern stream cipher.
    // https://eden.dei.uc.pt/~sneves/pubs/2011-snfa2.pdf
    // Period: ~2^127
    // No systematic BigCrush failures reported.


    // The original ARC4-based prng included in this library.
    // Period: ~2^1600


    seedrandom.alea = alea;
    seedrandom.xor128 = xor128;
    seedrandom.xorwow = xorwow;
    seedrandom.xorshift7 = xorshift7;
    seedrandom.xor4096 = xor4096;
    seedrandom.tychei = tychei;

    var seedrandom$1 = seedrandom;
    var seedrandom_1 = seedrandom$1.alea;

    var util = createCommonjsModule(function (module, exports) {
    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    /**
     * Shuffles the array in-place using Fisher-Yates algorithm.
     *
     * ```js
     * const a = [1, 2, 3, 4, 5];
     * tf.util.shuffle(a);
     * console.log(a);
     * ```
     *
     * @param array The array to shuffle in-place.
     */
    /** @doc {heading: 'Util'} */
    // tslint:disable-next-line:no-any
    function shuffle(array) {
        var counter = array.length;
        var temp = 0;
        var index = 0;
        // While there are elements in the array
        while (counter > 0) {
            // Pick a random index
            index = (Math.random() * counter) | 0;
            // Decrease counter by 1
            counter--;
            // And swap the last element with it
            temp = array[counter];
            array[counter] = array[index];
            array[index] = temp;
        }
    }
    exports.shuffle = shuffle;
    /** Clamps a value to a specified range. */
    function clamp(min, x, max) {
        return Math.max(min, Math.min(x, max));
    }
    exports.clamp = clamp;
    function nearestLargerEven(val) {
        return val % 2 === 0 ? val : val + 1;
    }
    exports.nearestLargerEven = nearestLargerEven;
    function sum(arr) {
        var sum = 0;
        for (var i = 0; i < arr.length; i++) {
            sum += arr[i];
        }
        return sum;
    }
    exports.sum = sum;
    /**
     * Returns a sample from a uniform [a, b) distribution.
     *
     * @param a The minimum support (inclusive).
     * @param b The maximum support (exclusive).
     * @return A pseudorandom number on the half-open interval [a,b).
     */
    function randUniform(a, b) {
        var r = Math.random();
        return (b * r) + (1 - r) * a;
    }
    exports.randUniform = randUniform;
    /** Returns the squared Euclidean distance between two vectors. */
    function distSquared(a, b) {
        var result = 0;
        for (var i = 0; i < a.length; i++) {
            var diff = Number(a[i]) - Number(b[i]);
            result += diff * diff;
        }
        return result;
    }
    exports.distSquared = distSquared;
    /**
     * Asserts that the expression is true. Otherwise throws an error with the
     * provided message.
     *
     * ```js
     * tf.util.assert(2 === 3, 'Two is not three');
     * ```
     *
     * @param expr The expression to assert (as a boolean).
     * @param msg A function that returns the message to report when throwing an
     *     error. We use a function for performance reasons.
     */
    /** @doc {heading: 'Util'} */
    function assert(expr, msg) {
        if (!expr) {
            throw new Error(typeof msg === 'string' ? msg : msg());
        }
    }
    exports.assert = assert;
    function assertShapesMatch(shapeA, shapeB, errorMessagePrefix) {
        if (errorMessagePrefix === void 0) { errorMessagePrefix = ''; }
        assert(arraysEqual(shapeA, shapeB), function () { return errorMessagePrefix + (" Shapes " + shapeA + " and " + shapeB + " must match"); });
    }
    exports.assertShapesMatch = assertShapesMatch;
    function assertNonNull(a) {
        assert(a != null, function () { return "The input to the tensor constructor must be a non-null value."; });
    }
    exports.assertNonNull = assertNonNull;
    // NOTE: We explicitly type out what T extends instead of any so that
    // util.flatten on a nested array of number doesn't try to infer T as a
    // number[][], causing us to explicitly type util.flatten<number>().
    /**
     *  Flattens an arbitrarily nested array.
     *
     * ```js
     * const a = [[1, 2], [3, 4], [5, [6, [7]]]];
     * const flat = tf.util.flatten(a);
     * console.log(flat);
     * ```
     *
     *  @param arr The nested array to flatten.
     *  @param result The destination array which holds the elements.
     */
    /** @doc {heading: 'Util'} */
    function flatten(arr, result) {
        if (result === void 0) { result = []; }
        if (result == null) {
            result = [];
        }
        if (Array.isArray(arr) || isTypedArray(arr)) {
            for (var i = 0; i < arr.length; ++i) {
                flatten(arr[i], result);
            }
        }
        else {
            result.push(arr);
        }
        return result;
    }
    exports.flatten = flatten;
    /**
     * Returns the size (number of elements) of the tensor given its shape.
     *
     * ```js
     * const shape = [3, 4, 2];
     * const size = tf.util.sizeFromShape(shape);
     * console.log(size);
     * ```
     */
    /** @doc {heading: 'Util'} */
    function sizeFromShape(shape) {
        if (shape.length === 0) {
            // Scalar.
            return 1;
        }
        var size = shape[0];
        for (var i = 1; i < shape.length; i++) {
            size *= shape[i];
        }
        return size;
    }
    exports.sizeFromShape = sizeFromShape;
    function isScalarShape(shape) {
        return shape.length === 0;
    }
    exports.isScalarShape = isScalarShape;
    function arraysEqual(n1, n2) {
        if (n1 === n2) {
            return true;
        }
        if (n1 == null || n2 == null) {
            return false;
        }
        if (n1.length !== n2.length) {
            return false;
        }
        for (var i = 0; i < n1.length; i++) {
            if (n1[i] !== n2[i]) {
                return false;
            }
        }
        return true;
    }
    exports.arraysEqual = arraysEqual;
    function isInt(a) {
        return a % 1 === 0;
    }
    exports.isInt = isInt;
    function tanh(x) {
        // tslint:disable-next-line:no-any
        if (Math.tanh != null) {
            // tslint:disable-next-line:no-any
            return Math.tanh(x);
        }
        if (x === Infinity) {
            return 1;
        }
        else if (x === -Infinity) {
            return -1;
        }
        else {
            var e2x = Math.exp(2 * x);
            return (e2x - 1) / (e2x + 1);
        }
    }
    exports.tanh = tanh;
    function sizeToSquarishShape(size) {
        var width = Math.ceil(Math.sqrt(size));
        return [width, Math.ceil(size / width)];
    }
    exports.sizeToSquarishShape = sizeToSquarishShape;
    function createShuffledIndices(n) {
        var shuffledIndices = new Uint32Array(n);
        for (var i = 0; i < n; ++i) {
            shuffledIndices[i] = i;
        }
        shuffle(shuffledIndices);
        return shuffledIndices;
    }
    exports.createShuffledIndices = createShuffledIndices;
    function rightPad(a, size) {
        if (size <= a.length) {
            return a;
        }
        return a + ' '.repeat(size - a.length);
    }
    exports.rightPad = rightPad;
    function repeatedTry(checkFn, delayFn, maxCounter) {
        if (delayFn === void 0) { delayFn = function (counter) { return 0; }; }
        return new Promise(function (resolve, reject) {
            var tryCount = 0;
            var tryFn = function () {
                if (checkFn()) {
                    resolve();
                    return;
                }
                tryCount++;
                var nextBackoff = delayFn(tryCount);
                if (maxCounter != null && tryCount >= maxCounter) {
                    reject();
                    return;
                }
                setTimeout(tryFn, nextBackoff);
            };
            tryFn();
        });
    }
    exports.repeatedTry = repeatedTry;
    /**
     * Given the full size of the array and a shape that may contain -1 as the
     * implicit dimension, returns the inferred shape where -1 is replaced.
     * E.g. For shape=[2, -1, 3] and size=24, it will return [2, 4, 3].
     *
     * @param shape The shape, which may contain -1 in some dimension.
     * @param size The full size (number of elements) of the array.
     * @return The inferred shape where -1 is replaced with the inferred size.
     */
    function inferFromImplicitShape(shape, size) {
        var shapeProd = 1;
        var implicitIdx = -1;
        for (var i = 0; i < shape.length; ++i) {
            if (shape[i] >= 0) {
                shapeProd *= shape[i];
            }
            else if (shape[i] === -1) {
                if (implicitIdx !== -1) {
                    throw Error("Shapes can only have 1 implicit size. " +
                        ("Found -1 at dim " + implicitIdx + " and dim " + i));
                }
                implicitIdx = i;
            }
            else if (shape[i] < 0) {
                throw Error("Shapes can not be < 0. Found " + shape[i] + " at dim " + i);
            }
        }
        if (implicitIdx === -1) {
            if (size > 0 && size !== shapeProd) {
                throw Error("Size(" + size + ") must match the product of shape " + shape);
            }
            return shape;
        }
        if (shapeProd === 0) {
            throw Error("Cannot infer the missing size in [" + shape + "] when " +
                "there are 0 elements");
        }
        if (size % shapeProd !== 0) {
            throw Error("The implicit shape can't be a fractional number. " +
                ("Got " + size + " / " + shapeProd));
        }
        var newShape = shape.slice();
        newShape[implicitIdx] = size / shapeProd;
        return newShape;
    }
    exports.inferFromImplicitShape = inferFromImplicitShape;
    function parseAxisParam(axis, shape) {
        var rank = shape.length;
        // Normalize input
        axis = axis == null ? shape.map(function (s, i) { return i; }) : [].concat(axis);
        // Check for valid range
        assert(axis.every(function (ax) { return ax >= -rank && ax < rank; }), function () {
            return "All values in axis param must be in range [-" + rank + ", " + rank + ") but " +
                ("got axis " + axis);
        });
        // Check for only integers
        assert(axis.every(function (ax) { return isInt(ax); }), function () { return "All values in axis param must be integers but " +
            ("got axis " + axis); });
        // Handle negative axis.
        return axis.map(function (a) { return a < 0 ? rank + a : a; });
    }
    exports.parseAxisParam = parseAxisParam;
    /** Reduces the shape by removing all dimensions of shape 1. */
    function squeezeShape(shape, axis) {
        var newShape = [];
        var keptDims = [];
        var axes = axis == null ? null : parseAxisParam(axis, shape).sort();
        var j = 0;
        for (var i = 0; i < shape.length; ++i) {
            if (axes != null) {
                if (axes[j] === i && shape[i] !== 1) {
                    throw new Error("Can't squeeze axis " + i + " since its dim '" + shape[i] + "' is not 1");
                }
                if ((axes[j] == null || axes[j] > i) && shape[i] === 1) {
                    newShape.push(shape[i]);
                    keptDims.push(i);
                }
                if (axes[j] <= i) {
                    j++;
                }
            }
            if (shape[i] !== 1) {
                newShape.push(shape[i]);
                keptDims.push(i);
            }
        }
        return { newShape: newShape, keptDims: keptDims };
    }
    exports.squeezeShape = squeezeShape;
    function getTypedArrayFromDType(dtype, size) {
        var values = null;
        if (dtype == null || dtype === 'float32') {
            values = new Float32Array(size);
        }
        else if (dtype === 'int32') {
            values = new Int32Array(size);
        }
        else if (dtype === 'bool') {
            values = new Uint8Array(size);
        }
        else {
            throw new Error("Unknown data type " + dtype);
        }
        return values;
    }
    exports.getTypedArrayFromDType = getTypedArrayFromDType;
    function getArrayFromDType(dtype, size) {
        var values = null;
        if (dtype == null || dtype === 'float32') {
            values = new Float32Array(size);
        }
        else if (dtype === 'int32') {
            values = new Int32Array(size);
        }
        else if (dtype === 'bool') {
            values = new Uint8Array(size);
        }
        else if (dtype === 'string') {
            values = new Array(size);
        }
        else {
            throw new Error("Unknown data type " + dtype);
        }
        return values;
    }
    exports.getArrayFromDType = getArrayFromDType;
    function checkComputationForErrors(vals, dtype, name) {
        if (dtype !== 'float32') {
            // Only floating point computations will generate NaN values
            return;
        }
        for (var i = 0; i < vals.length; i++) {
            var num = vals[i];
            if (isNaN(num) || !isFinite(num)) {
                throw Error("The result of the '" + name + "' is " + num + ".");
            }
        }
    }
    exports.checkComputationForErrors = checkComputationForErrors;
    function checkConversionForErrors(vals, dtype) {
        for (var i = 0; i < vals.length; i++) {
            var num = vals[i];
            if (isNaN(num) || !isFinite(num)) {
                throw Error("A tensor of type " + dtype + " being uploaded contains " + num + ".");
            }
        }
    }
    exports.checkConversionForErrors = checkConversionForErrors;
    /**
     * Returns true if the new type can't encode the old type without loss of
     * precision.
     */
    function hasEncodingLoss(oldType, newType) {
        if (newType === 'complex64') {
            return false;
        }
        if (newType === 'float32' && oldType !== 'complex64') {
            return false;
        }
        if (newType === 'int32' && oldType !== 'float32' && oldType !== 'complex64') {
            return false;
        }
        if (newType === 'bool' && oldType === 'bool') {
            return false;
        }
        return true;
    }
    exports.hasEncodingLoss = hasEncodingLoss;
    function isTypedArray(a) {
        return a instanceof Float32Array || a instanceof Int32Array ||
            a instanceof Uint8Array;
    }
    exports.isTypedArray = isTypedArray;
    function bytesPerElement(dtype) {
        if (dtype === 'float32' || dtype === 'int32') {
            return 4;
        }
        else if (dtype === 'complex64') {
            return 8;
        }
        else if (dtype === 'bool') {
            return 1;
        }
        else {
            throw new Error("Unknown dtype " + dtype);
        }
    }
    exports.bytesPerElement = bytesPerElement;
    /**
     * Returns the approximate number of bytes allocated in the string array - 2
     * bytes per character. Computing the exact bytes for a native string in JS is
     * not possible since it depends on the encoding of the html page that serves
     * the website.
     */
    function bytesFromStringArray(arr) {
        if (arr == null) {
            return 0;
        }
        var bytes = 0;
        arr.forEach(function (x) { return bytes += x.length * 2; });
        return bytes;
    }
    exports.bytesFromStringArray = bytesFromStringArray;
    /** Returns true if the value is a string. */
    function isString(value) {
        return typeof value === 'string' || value instanceof String;
    }
    exports.isString = isString;
    function isBoolean(value) {
        return typeof value === 'boolean';
    }
    exports.isBoolean = isBoolean;
    function isNumber(value) {
        return typeof value === 'number';
    }
    exports.isNumber = isNumber;
    function inferDtype(values) {
        if (Array.isArray(values)) {
            return inferDtype(values[0]);
        }
        if (values instanceof Float32Array) {
            return 'float32';
        }
        else if (values instanceof Int32Array || values instanceof Uint8Array) {
            return 'int32';
        }
        else if (isNumber(values)) {
            return 'float32';
        }
        else if (isString(values)) {
            return 'string';
        }
        else if (isBoolean(values)) {
            return 'bool';
        }
        return 'float32';
    }
    exports.inferDtype = inferDtype;
    function isFunction(f) {
        return !!(f && f.constructor && f.call && f.apply);
    }
    exports.isFunction = isFunction;
    function nearestDivisor(size, start) {
        for (var i = start; i < size; ++i) {
            if (size % i === 0) {
                return i;
            }
        }
        return size;
    }
    exports.nearestDivisor = nearestDivisor;
    function computeStrides(shape) {
        var rank = shape.length;
        if (rank < 2) {
            return [];
        }
        // Last dimension has implicit stride of 1, thus having D-1 (instead of D)
        // strides.
        var strides = new Array(rank - 1);
        strides[rank - 2] = shape[rank - 1];
        for (var i = rank - 3; i >= 0; --i) {
            strides[i] = strides[i + 1] * shape[i + 1];
        }
        return strides;
    }
    exports.computeStrides = computeStrides;
    function toTypedArray(a, dtype, debugMode) {
        if (dtype === 'string') {
            throw new Error('Cannot convert a string[] to a TypedArray');
        }
        if (Array.isArray(a)) {
            a = flatten(a);
        }
        if (debugMode) {
            checkConversionForErrors(a, dtype);
        }
        if (noConversionNeeded(a, dtype)) {
            return a;
        }
        if (dtype == null || dtype === 'float32' || dtype === 'complex64') {
            return new Float32Array(a);
        }
        else if (dtype === 'int32') {
            return new Int32Array(a);
        }
        else if (dtype === 'bool') {
            var bool = new Uint8Array(a.length);
            for (var i = 0; i < bool.length; ++i) {
                if (Math.round(a[i]) !== 0) {
                    bool[i] = 1;
                }
            }
            return bool;
        }
        else {
            throw new Error("Unknown data type " + dtype);
        }
    }
    exports.toTypedArray = toTypedArray;
    function createNestedArray(offset, shape, a) {
        var ret = new Array();
        if (shape.length === 1) {
            var d = shape[0];
            for (var i = 0; i < d; i++) {
                ret[i] = a[offset + i];
            }
        }
        else {
            var d = shape[0];
            var rest = shape.slice(1);
            var len = rest.reduce(function (acc, c) { return acc * c; });
            for (var i = 0; i < d; i++) {
                ret[i] = createNestedArray(offset + i * len, rest, a);
            }
        }
        return ret;
    }
    // Provide a nested array of TypedArray in given shape.
    function toNestedArray(shape, a) {
        if (shape.length === 0) {
            // Scalar type should return a single number.
            return a[0];
        }
        var size = shape.reduce(function (acc, c) { return acc * c; });
        if (size === 0) {
            // A tensor with shape zero should be turned into empty list.
            return [];
        }
        if (size !== a.length) {
            throw new Error("[" + shape + "] does not match the input size.");
        }
        return createNestedArray(0, shape, a);
    }
    exports.toNestedArray = toNestedArray;
    function noConversionNeeded(a, dtype) {
        return (a instanceof Float32Array && dtype === 'float32') ||
            (a instanceof Int32Array && dtype === 'int32') ||
            (a instanceof Uint8Array && dtype === 'bool');
    }
    function makeOnesTypedArray(size, dtype) {
        var array = makeZerosTypedArray(size, dtype);
        for (var i = 0; i < array.length; i++) {
            array[i] = 1;
        }
        return array;
    }
    exports.makeOnesTypedArray = makeOnesTypedArray;
    function makeZerosTypedArray(size, dtype) {
        if (dtype == null || dtype === 'float32' || dtype === 'complex64') {
            return new Float32Array(size);
        }
        else if (dtype === 'int32') {
            return new Int32Array(size);
        }
        else if (dtype === 'bool') {
            return new Uint8Array(size);
        }
        else {
            throw new Error("Unknown data type " + dtype);
        }
    }
    exports.makeZerosTypedArray = makeZerosTypedArray;
    /**
     * Returns the current high-resolution time in milliseconds relative to an
     * arbitrary time in the past. It works across different platforms (node.js,
     * browsers).
     *
     * ```js
     * console.log(tf.util.now());
     * ```
     */
    /** @doc {heading: 'Util'} */
    function now() {
        if (typeof performance !== 'undefined') {
            return performance.now();
        }
        else if (typeof process !== 'undefined') {
            var time = process.hrtime();
            return time[0] * 1000 + time[1] / 1000000;
        }
        else {
            throw new Error('Cannot measure time in this environment. You should run tf.js ' +
                'in the browser or in Node.js');
        }
    }
    exports.now = now;
    function assertNonNegativeIntegerDimensions(shape) {
        shape.forEach(function (dimSize) {
            assert(Number.isInteger(dimSize) && dimSize >= 0, function () {
                return "Tensor must have a shape comprised of positive integers but got " +
                    ("shape [" + shape + "].");
            });
        });
    }
    exports.assertNonNegativeIntegerDimensions = assertNonNegativeIntegerDimensions;

    });

    unwrapExports(util);
    var util_1 = util.shuffle;
    var util_2 = util.clamp;
    var util_3 = util.nearestLargerEven;
    var util_4 = util.sum;
    var util_5 = util.randUniform;
    var util_6 = util.distSquared;
    var util_7 = util.assert;
    var util_8 = util.assertShapesMatch;
    var util_9 = util.assertNonNull;
    var util_10 = util.flatten;
    var util_11 = util.sizeFromShape;
    var util_12 = util.isScalarShape;
    var util_13 = util.arraysEqual;
    var util_14 = util.isInt;
    var util_15 = util.tanh;
    var util_16 = util.sizeToSquarishShape;
    var util_17 = util.createShuffledIndices;
    var util_18 = util.rightPad;
    var util_19 = util.repeatedTry;
    var util_20 = util.inferFromImplicitShape;
    var util_21 = util.parseAxisParam;
    var util_22 = util.squeezeShape;
    var util_23 = util.getTypedArrayFromDType;
    var util_24 = util.getArrayFromDType;
    var util_25 = util.checkComputationForErrors;
    var util_26 = util.checkConversionForErrors;
    var util_27 = util.hasEncodingLoss;
    var util_28 = util.isTypedArray;
    var util_29 = util.bytesPerElement;
    var util_30 = util.bytesFromStringArray;
    var util_31 = util.isString;
    var util_32 = util.isBoolean;
    var util_33 = util.isNumber;
    var util_34 = util.inferDtype;
    var util_35 = util.isFunction;
    var util_36 = util.nearestDivisor;
    var util_37 = util.computeStrides;
    var util_38 = util.toTypedArray;
    var util_39 = util.toNestedArray;
    var util_40 = util.makeOnesTypedArray;
    var util_41 = util.makeZerosTypedArray;
    var util_42 = util.now;
    var util_43 = util.assertNonNegativeIntegerDimensions;

    var tensor_format = createCommonjsModule(function (module, exports) {
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Object.defineProperty(exports, "__esModule", { value: true });

    // Maximum number of values before we decide to show ellipsis.
    var FORMAT_LIMIT_NUM_VALS = 20;
    // Number of first and last values to show when displaying a, b,...,y, z.
    var FORMAT_NUM_FIRST_LAST_VALS = 3;
    // Number of significant digits to show.
    var FORMAT_NUM_SIG_DIGITS = 7;
    function tensorToString(vals, shape, dtype, verbose) {
        var strides = util.computeStrides(shape);
        var padPerCol = computeMaxSizePerColumn(vals, shape, dtype, strides);
        var rank = shape.length;
        var valsLines = subTensorToString(vals, shape, dtype, strides, padPerCol);
        var lines = ['Tensor'];
        if (verbose) {
            lines.push("  dtype: " + dtype);
            lines.push("  rank: " + rank);
            lines.push("  shape: [" + shape + "]");
            lines.push("  values:");
        }
        lines.push(valsLines.map(function (l) { return '    ' + l; }).join('\n'));
        return lines.join('\n');
    }
    exports.tensorToString = tensorToString;
    function computeMaxSizePerColumn(vals, shape, dtype, strides) {
        var n = util.sizeFromShape(shape);
        var numCols = strides[strides.length - 1];
        var padPerCol = new Array(numCols).fill(0);
        var rank = shape.length;
        var valuesOrTuples = dtype === 'complex64' ? createComplexTuples(vals) : vals;
        if (rank > 1) {
            for (var row = 0; row < n / numCols; row++) {
                var offset = row * numCols;
                for (var j = 0; j < numCols; j++) {
                    padPerCol[j] = Math.max(padPerCol[j], valToString(valuesOrTuples[offset + j], 0, dtype).length);
                }
            }
        }
        return padPerCol;
    }
    function valToString(val, pad, dtype) {
        var valStr;
        if (Array.isArray(val)) {
            valStr = parseFloat(val[0].toFixed(FORMAT_NUM_SIG_DIGITS)) + " + " +
                (parseFloat(val[1].toFixed(FORMAT_NUM_SIG_DIGITS)) + "j");
        }
        else if (util.isString(val)) {
            valStr = "'" + val + "'";
        }
        else if (dtype === 'bool') {
            valStr = boolNumToString(val);
        }
        else {
            valStr = parseFloat(val.toFixed(FORMAT_NUM_SIG_DIGITS)).toString();
        }
        return util.rightPad(valStr, pad);
    }
    function boolNumToString(v) {
        return v === 0 ? 'false' : 'true';
    }
    function subTensorToString(vals, shape, dtype, strides, padPerCol, isLast) {
        if (isLast === void 0) { isLast = true; }
        var storagePerElement = dtype === 'complex64' ? 2 : 1;
        var size = shape[0];
        var rank = shape.length;
        if (rank === 0) {
            if (dtype === 'complex64') {
                var complexTuple = createComplexTuples(vals);
                return [valToString(complexTuple[0], 0, dtype)];
            }
            if (dtype === 'bool') {
                return [boolNumToString(vals[0])];
            }
            return [vals[0].toString()];
        }
        if (rank === 1) {
            if (size > FORMAT_LIMIT_NUM_VALS) {
                var firstValsSize = FORMAT_NUM_FIRST_LAST_VALS * storagePerElement;
                var firstVals = Array.from(vals.slice(0, firstValsSize));
                var lastVals = Array.from(vals.slice(size - FORMAT_NUM_FIRST_LAST_VALS * storagePerElement, size));
                if (dtype === 'complex64') {
                    firstVals = createComplexTuples(firstVals);
                    lastVals = createComplexTuples(lastVals);
                }
                return [
                    '[' + firstVals.map(function (x, i) { return valToString(x, padPerCol[i], dtype); }).join(', ') +
                        ', ..., ' +
                        lastVals
                            .map(function (x, i) { return valToString(x, padPerCol[size - FORMAT_NUM_FIRST_LAST_VALS + i], dtype); })
                            .join(', ') +
                        ']'
                ];
            }
            var displayVals = dtype === 'complex64' ? createComplexTuples(vals) :
                Array.from(vals);
            return [
                '[' + displayVals.map(function (x, i) { return valToString(x, padPerCol[i], dtype); }).join(', ') +
                    ']'
            ];
        }
        // The array is rank 2 or more.
        var subshape = shape.slice(1);
        var substrides = strides.slice(1);
        var stride = strides[0] * storagePerElement;
        var lines = [];
        if (size > FORMAT_LIMIT_NUM_VALS) {
            for (var i = 0; i < FORMAT_NUM_FIRST_LAST_VALS; i++) {
                var start = i * stride;
                var end = start + stride;
                lines.push.apply(lines, subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, false /* isLast */));
            }
            lines.push('...');
            for (var i = size - FORMAT_NUM_FIRST_LAST_VALS; i < size; i++) {
                var start = i * stride;
                var end = start + stride;
                lines.push.apply(lines, subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));
            }
        }
        else {
            for (var i = 0; i < size; i++) {
                var start = i * stride;
                var end = start + stride;
                lines.push.apply(lines, subTensorToString(vals.slice(start, end), subshape, dtype, substrides, padPerCol, i === size - 1 /* isLast */));
            }
        }
        var sep = rank === 2 ? ',' : '';
        lines[0] = '[' + lines[0] + sep;
        for (var i = 1; i < lines.length - 1; i++) {
            lines[i] = ' ' + lines[i] + sep;
        }
        var newLineSep = ',\n';
        for (var i = 2; i < rank; i++) {
            newLineSep += '\n';
        }
        lines[lines.length - 1] =
            ' ' + lines[lines.length - 1] + ']' + (isLast ? '' : newLineSep);
        return lines;
    }
    function createComplexTuples(vals) {
        var complexTuples = [];
        for (var i = 0; i < vals.length; i += 2) {
            complexTuples.push([vals[i], vals[i + 1]]);
        }
        return complexTuples;
    }

    });

    unwrapExports(tensor_format);
    var tensor_format_1 = tensor_format.tensorToString;

    var tensor = createCommonjsModule(function (module, exports) {
    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    var __extends = (commonjsGlobal && commonjsGlobal.__extends) || (function () {
        var extendStatics = function (d, b) {
            extendStatics = Object.setPrototypeOf ||
                ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
                function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
            return extendStatics(d, b);
        };
        return function (d, b) {
            extendStatics(d, b);
            function __() { this.constructor = d; }
            d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
        };
    })();
    var __awaiter = (commonjsGlobal && commonjsGlobal.__awaiter) || function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };
    var __generator = (commonjsGlobal && commonjsGlobal.__generator) || function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [op[0] & 2, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };
    Object.defineProperty(exports, "__esModule", { value: true });


    var util_1 = util;
    /**
     * A mutable object, similar to `tf.Tensor`, that allows users to set values
     * at locations before converting to an immutable `tf.Tensor`.
     *
     * See `tf.buffer` for creating a tensor buffer.
     */
    /** @doc {heading: 'Tensors', subheading: 'Classes'} */
    var TensorBuffer = /** @class */ (function () {
        function TensorBuffer(shape, dtype, values) {
            var _this = this;
            this.dtype = dtype;
            this.shape = shape.slice();
            this.size = util.sizeFromShape(shape);
            if (values != null) {
                var n_1 = values.length;
                util.assert(n_1 === this.size, function () { return "Length of values '" + n_1 + "' does not match the size " +
                    ("inferred by the shape '" + _this.size + "'."); });
            }
            if (dtype === 'complex64') {
                throw new Error("complex64 dtype TensorBuffers are not supported. Please create " +
                    "a TensorBuffer for the real and imaginary parts separately and " +
                    "call tf.complex(real, imag).");
            }
            this.values =
                values || util.getArrayFromDType(dtype, this.size);
            this.strides = util_1.computeStrides(shape);
        }
        /**
         * Sets a value in the buffer at a given location.
         *
         * @param value The value to set.
         * @param locs  The location indices.
         */
        /** @doc {heading: 'Tensors', subheading: 'Creation'} */
        TensorBuffer.prototype.set = function (value) {
            var _this = this;
            var locs = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                locs[_i - 1] = arguments[_i];
            }
            if (locs.length === 0) {
                locs = [0];
            }
            util.assert(locs.length === this.rank, function () { return "The number of provided coordinates (" + locs.length + ") must " +
                ("match the rank (" + _this.rank + ")"); });
            var index = this.locToIndex(locs);
            this.values[index] = value;
        };
        /**
         * Returns the value in the buffer at the provided location.
         *
         * @param locs The location indices.
         */
        /** @doc {heading: 'Tensors', subheading: 'Creation'} */
        TensorBuffer.prototype.get = function () {
            var locs = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                locs[_i] = arguments[_i];
            }
            if (locs.length === 0) {
                locs = [0];
            }
            var index = locs[locs.length - 1];
            for (var i = 0; i < locs.length - 1; ++i) {
                index += this.strides[i] * locs[i];
            }
            return this.values[index];
        };
        TensorBuffer.prototype.locToIndex = function (locs) {
            if (this.rank === 0) {
                return 0;
            }
            else if (this.rank === 1) {
                return locs[0];
            }
            var index = locs[locs.length - 1];
            for (var i = 0; i < locs.length - 1; ++i) {
                index += this.strides[i] * locs[i];
            }
            return index;
        };
        TensorBuffer.prototype.indexToLoc = function (index) {
            if (this.rank === 0) {
                return [];
            }
            else if (this.rank === 1) {
                return [index];
            }
            var locs = new Array(this.shape.length);
            for (var i = 0; i < locs.length - 1; ++i) {
                locs[i] = Math.floor(index / this.strides[i]);
                index -= locs[i] * this.strides[i];
            }
            locs[locs.length - 1] = index;
            return locs;
        };
        Object.defineProperty(TensorBuffer.prototype, "rank", {
            get: function () {
                return this.shape.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * Creates an immutable `tf.Tensor` object from the buffer.
         */
        /** @doc {heading: 'Tensors', subheading: 'Creation'} */
        TensorBuffer.prototype.toTensor = function () {
            return Tensor.make(this.shape, { values: this.values }, this.dtype);
        };
        return TensorBuffer;
    }());
    exports.TensorBuffer = TensorBuffer;
    // For tracking tensor creation and disposal.
    var trackerFn = null;
    // Used by chaining methods to call into ops.
    var opHandler = null;
    // Used to warn about deprecated methods.
    var deprecationWarningFn = null;
    /**
     * An external consumer can register itself as the tensor tracker. This way
     * the Tensor class can notify the tracker for every tensor created and
     * disposed.
     */
    function setTensorTracker(fn) {
        trackerFn = fn;
    }
    exports.setTensorTracker = setTensorTracker;
    /**
     * An external consumer can register itself as the op handler. This way the
     * Tensor class can have chaining methods that call into ops via the op handler.
     */
    function setOpHandler(handler) {
        opHandler = handler;
    }
    exports.setOpHandler = setOpHandler;
    /**
     * Sets the deprecation warning function to be used by this file. This way the
     * Tensor class can be a leaf but still use the environment.
     */
    function setDeprecationWarningFn(fn) {
        deprecationWarningFn = fn;
    }
    exports.setDeprecationWarningFn = setDeprecationWarningFn;
    /**
     * A `tf.Tensor` object represents an immutable, multidimensional array of
     * numbers that has a shape and a data type.
     *
     * See `tf.tensor` for details on how to create a `tf.Tensor`.
     */
    /** @doc {heading: 'Tensors', subheading: 'Classes'} */
    var Tensor = /** @class */ (function () {
        function Tensor(shape, dtype, values, dataId, backend) {
            this.isDisposedInternal = false;
            this.shape = shape.slice();
            this.dtype = dtype || 'float32';
            this.size = util.sizeFromShape(shape);
            this.strides = util_1.computeStrides(shape);
            this.dataId = dataId != null ? dataId : {};
            this.id = trackerFn().nextTensorId();
            this.rankType = (this.rank < 5 ? this.rank.toString() : 'higher');
            trackerFn().registerTensor(this, backend);
            if (values != null) {
                trackerFn().write(this.dataId, values);
            }
        }
        /**
         * Makes a new tensor with the provided shape and values. Values should be in
         * a flat array.
         */
        Tensor.make = function (shape, data, dtype, backend) {
            return new Tensor(shape, dtype, data.values, data.dataId, backend);
        };
        /** Flatten a Tensor to a 1D array. */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.flatten = function () {
            this.throwIfDisposed();
            return this.as1D();
        };
        /** Converts a size-1 `tf.Tensor` to a `tf.Scalar`. */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.asScalar = function () {
            this.throwIfDisposed();
            util.assert(this.size === 1, function () { return 'The array must have only 1 element.'; });
            return this.reshape([]);
        };
        /** Converts a `tf.Tensor` to a `tf.Tensor1D`. */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.as1D = function () {
            this.throwIfDisposed();
            return this.reshape([this.size]);
        };
        /**
         * Converts a `tf.Tensor` to a `tf.Tensor2D`.
         *
         * @param rows Number of rows in `tf.Tensor2D`.
         * @param columns Number of columns in `tf.Tensor2D`.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.as2D = function (rows, columns) {
            this.throwIfDisposed();
            return this.reshape([rows, columns]);
        };
        /**
         * Converts a `tf.Tensor` to a `tf.Tensor3D`.
         *
         * @param rows Number of rows in `tf.Tensor3D`.
         * @param columns Number of columns in `tf.Tensor3D`.
         * @param depth Depth of `tf.Tensor3D`.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.as3D = function (rows, columns, depth) {
            this.throwIfDisposed();
            return this.reshape([rows, columns, depth]);
        };
        /**
         * Converts a `tf.Tensor` to a `tf.Tensor4D`.
         *
         * @param rows Number of rows in `tf.Tensor4D`.
         * @param columns Number of columns in `tf.Tensor4D`.
         * @param depth Depth of `tf.Tensor4D`.
         * @param depth2 4th dimension of `tf.Tensor4D`.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.as4D = function (rows, columns, depth, depth2) {
            this.throwIfDisposed();
            return this.reshape([rows, columns, depth, depth2]);
        };
        /**
         * Converts a `tf.Tensor` to a `tf.Tensor5D`.
         *
         * @param rows Number of rows in `tf.Tensor5D`.
         * @param columns Number of columns in `tf.Tensor5D`.
         * @param depth Depth of `tf.Tensor5D`.
         * @param depth2 4th dimension of `tf.Tensor5D`.
         * @param depth3 5th dimension of 'tf.Tensor5D'
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.as5D = function (rows, columns, depth, depth2, depth3) {
            this.throwIfDisposed();
            return this.reshape([rows, columns, depth, depth2, depth3]);
        };
        /**
         * Casts a `tf.Tensor` to a specified dtype.
         *
         * @param dtype Data-type to cast the tensor to.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.asType = function (dtype) {
            this.throwIfDisposed();
            return opHandler.cast(this, dtype);
        };
        Object.defineProperty(Tensor.prototype, "rank", {
            get: function () {
                return this.shape.length;
            },
            enumerable: true,
            configurable: true
        });
        /** Returns a promise of `tf.TensorBuffer` that holds the underlying data. */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.buffer = function () {
            return __awaiter(this, void 0, void 0, function () {
                var vals;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.data()];
                        case 1:
                            vals = _a.sent();
                            return [2 /*return*/, opHandler.buffer(this.shape, this.dtype, vals)];
                    }
                });
            });
        };
        /** Returns a `tf.TensorBuffer` that holds the underlying data. */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.bufferSync = function () {
            return opHandler.buffer(this.shape, this.dtype, this.dataSync());
        };
        /**
         * Returns the tensor data as a nested array. The transfer of data is done
         * asynchronously.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.array = function () {
            return __awaiter(this, void 0, void 0, function () {
                var vals;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.data()];
                        case 1:
                            vals = _a.sent();
                            return [2 /*return*/, util_1.toNestedArray(this.shape, vals)];
                    }
                });
            });
        };
        /**
         * Returns the tensor data as a nested array. The transfer of data is done
         * synchronously.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.arraySync = function () {
            return util_1.toNestedArray(this.shape, this.dataSync());
        };
        /**
         * Asynchronously downloads the values from the `tf.Tensor`. Returns a promise
         * of `TypedArray` that resolves when the computation has finished.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.data = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.throwIfDisposed();
                    return [2 /*return*/, trackerFn().read(this.dataId)];
                });
            });
        };
        /**
         * Synchronously downloads the values from the `tf.Tensor`. This blocks the UI
         * thread until the values are ready, which can cause performance issues.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.dataSync = function () {
            this.throwIfDisposed();
            return trackerFn().readSync(this.dataId);
        };
        /**
         * Disposes `tf.Tensor` from memory.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.dispose = function () {
            if (this.isDisposed) {
                return;
            }
            trackerFn().disposeTensor(this);
            this.isDisposedInternal = true;
        };
        Object.defineProperty(Tensor.prototype, "isDisposed", {
            get: function () {
                return this.isDisposedInternal;
            },
            enumerable: true,
            configurable: true
        });
        Tensor.prototype.throwIfDisposed = function () {
            if (this.isDisposed) {
                throw new Error("Tensor is disposed.");
            }
        };
        /** Casts the array to type `float32` */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.toFloat = function () {
            return this.asType('float32');
        };
        /** Casts the array to type `int32` */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.toInt = function () {
            return this.asType('int32');
        };
        /** Casts the array to type `bool` */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.toBool = function () {
            return this.asType('bool');
        };
        /**
         * Prints the `tf.Tensor`. See `tf.print` for details.
         *
         * @param verbose Whether to print verbose information about the tensor,
         *    including dtype and size.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.print = function (verbose) {
            if (verbose === void 0) { verbose = false; }
            return opHandler.print(this, verbose);
        };
        /**
         * Reshapes the tensor into the provided shape.
         * See `tf.reshape` for more details.
         *
         * @param newShape An array of integers defining the output tensor shape.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.reshape = function (newShape) {
            this.throwIfDisposed();
            return opHandler.reshape(this, newShape);
        };
        /**
         * Reshapes the tensor into the shape of the provided tensor.
         *
         * @param x The tensor of required shape.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.reshapeAs = function (x) {
            this.throwIfDisposed();
            return this.reshape(x.shape);
        };
        /**
         * Returns a `tf.Tensor` that has expanded rank, by inserting a dimension
         * into the tensor's shape. See `tf.expandDims` for details.
         *
         * @param axis The dimension index at which to insert shape of 1. Defaults to
         *    0 (the first dimension).
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.expandDims = function (axis) {
            if (axis === void 0) { axis = 0; }
            return opHandler.expandDims(this, axis);
        };
        /**
         * Returns the cumulative sum of the `tf.Tensor` along `axis`.
         *
         * @param axis The axis along which to sum. Optional. Defaults to 0.
         * @param exclusive Whether to perform exclusive cumulative sum. Defaults to
         *    false. If set to true then the sum of each tensor entry does not include
         *    its own value, but only the values previous to it along the specified
         *    axis.
         * @param reverse Whether to sum in the opposite direction. Defaults to
         *    false.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.cumsum = function (axis, exclusive, reverse) {
            if (axis === void 0) { axis = 0; }
            if (exclusive === void 0) { exclusive = false; }
            if (reverse === void 0) { reverse = false; }
            return opHandler.cumsum(this, axis, exclusive, reverse);
        };
        /**
         * Returns a `tf.Tensor` with dimensions of size 1 removed from the shape.
         * See `tf.squeeze` for more details.
         *
         * @param axis A list of numbers. If specified, only squeezes the
         *    dimensions listed. The dimension index starts at 0. It is an error to
         *    squeeze a dimension that is not 1.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.squeeze = function (axis) {
            this.throwIfDisposed();
            return opHandler.squeeze(this, axis);
        };
        /** Returns a copy of the tensor. See `tf.clone` for details. */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.clone = function () {
            this.throwIfDisposed();
            return opHandler.clone(this);
        };
        Tensor.prototype.oneHot = function (depth, onValue, offValue) {
            this.throwIfDisposed();
            return opHandler.oneHot(this, depth, onValue, offValue);
        };
        /** Returns a human-readable description of the tensor. Useful for logging. */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Tensor.prototype.toString = function (verbose) {
            if (verbose === void 0) { verbose = false; }
            var vals = this.dataSync();
            return tensor_format.tensorToString(vals, this.shape, this.dtype, verbose);
        };
        // Below is chain API that is not exposed to docs to avoid repetition. To
        // expose a method, move it above this comment and add @doc and jsdoc.
        Tensor.prototype.tile = function (reps) {
            this.throwIfDisposed();
            return opHandler.tile(this, reps);
        };
        Tensor.prototype.gather = function (indices, axis) {
            if (axis === void 0) { axis = 0; }
            this.throwIfDisposed();
            return opHandler.gather(this, indices, axis);
        };
        Tensor.prototype.matMul = function (b, transposeA, transposeB) {
            if (transposeA === void 0) { transposeA = false; }
            if (transposeB === void 0) { transposeB = false; }
            this.throwIfDisposed();
            return opHandler.matMul(this, b, transposeA, transposeB);
        };
        Tensor.prototype.dot = function (b) {
            this.throwIfDisposed();
            return opHandler.dot(this, b);
        };
        Tensor.prototype.norm = function (ord, axis, keepDims) {
            if (ord === void 0) { ord = 'euclidean'; }
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.norm(this, ord, axis, keepDims);
        };
        Tensor.prototype.slice = function (begin, size) {
            this.throwIfDisposed();
            return opHandler.slice(this, begin, size);
        };
        Tensor.prototype.reverse = function (axis) {
            this.throwIfDisposed();
            return opHandler.reverse(this, axis);
        };
        Tensor.prototype.concat = function (x, axis) {
            if (axis === void 0) { axis = 0; }
            this.throwIfDisposed();
            if (x instanceof Tensor) {
                x = [x];
            }
            return opHandler.concat([this].concat(x), axis);
        };
        Tensor.prototype.split = function (numOrSizeSplits, axis) {
            if (axis === void 0) { axis = 0; }
            this.throwIfDisposed();
            return opHandler.split(this, numOrSizeSplits, axis);
        };
        Tensor.prototype.stack = function (x, axis) {
            if (axis === void 0) { axis = 0; }
            return opHandler.stack([this, x], axis);
        };
        Tensor.prototype.unstack = function (axis) {
            if (axis === void 0) { axis = 0; }
            return opHandler.unstack(this, axis);
        };
        Tensor.prototype.pad = function (paddings, constantValue) {
            if (constantValue === void 0) { constantValue = 0; }
            return opHandler.pad(this, paddings, constantValue);
        };
        /**
         * @deprecated Use `tf.batchNorm` instead, and note the positional argument
         *     change of scale, offset, and varianceEpsilon.
         */
        Tensor.prototype.batchNormalization = function (mean, variance, varianceEpsilon, scale, offset) {
            if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
            deprecationWarningFn('tf.batchNormalization() is going away. ' +
                'Use tf.batchNorm() instead, and note the positional argument change ' +
                'of scale, offset, and varianceEpsilon');
            return this.batchNorm(mean, variance, offset, scale, varianceEpsilon);
        };
        Tensor.prototype.batchNorm = function (mean, variance, offset, scale, varianceEpsilon) {
            if (varianceEpsilon === void 0) { varianceEpsilon = .001; }
            this.throwIfDisposed();
            return opHandler.batchNorm(this, mean, variance, offset, scale, varianceEpsilon);
        };
        // Reduction ops.
        Tensor.prototype.all = function (axis, keepDims) {
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.all(this, axis, keepDims);
        };
        Tensor.prototype.any = function (axis, keepDims) {
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.any(this, axis, keepDims);
        };
        Tensor.prototype.logSumExp = function (axis, keepDims) {
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.logSumExp(this, axis, keepDims);
        };
        Tensor.prototype.sum = function (axis, keepDims) {
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.sum(this, axis, keepDims);
        };
        Tensor.prototype.prod = function (axis, keepDims) {
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.prod(this, axis, keepDims);
        };
        Tensor.prototype.mean = function (axis, keepDims) {
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.mean(this, axis, keepDims);
        };
        Tensor.prototype.min = function (axis, keepDims) {
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.min(this, axis, keepDims);
        };
        Tensor.prototype.max = function (axis, keepDims) {
            if (axis === void 0) { axis = null; }
            if (keepDims === void 0) { keepDims = false; }
            this.throwIfDisposed();
            return opHandler.max(this, axis, keepDims);
        };
        Tensor.prototype.argMin = function (axis) {
            if (axis === void 0) { axis = null; }
            this.throwIfDisposed();
            return opHandler.argMin(this, axis);
        };
        Tensor.prototype.argMax = function (axis) {
            if (axis === void 0) { axis = null; }
            this.throwIfDisposed();
            return opHandler.argMax(this, axis);
        };
        // Transformations
        Tensor.prototype.cast = function (dtype) {
            this.throwIfDisposed();
            return opHandler.cast(this, dtype);
        };
        // Binary ops.
        Tensor.prototype.add = function (x) {
            this.throwIfDisposed();
            return opHandler.add(this, x);
        };
        Tensor.prototype.addStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.addStrict(this, x);
        };
        Tensor.prototype.atan2 = function (x) {
            this.throwIfDisposed();
            return opHandler.atan2(this, x);
        };
        Tensor.prototype.sub = function (x) {
            this.throwIfDisposed();
            return opHandler.sub(this, x);
        };
        Tensor.prototype.subStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.subStrict(this, x);
        };
        Tensor.prototype.pow = function (exp) {
            this.throwIfDisposed();
            return opHandler.pow(this, exp);
        };
        Tensor.prototype.powStrict = function (exp) {
            this.throwIfDisposed();
            return opHandler.powStrict(this, exp);
        };
        Tensor.prototype.mul = function (x) {
            this.throwIfDisposed();
            return opHandler.mul(this, x);
        };
        Tensor.prototype.mulStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.mulStrict(this, x);
        };
        Tensor.prototype.div = function (x) {
            this.throwIfDisposed();
            return opHandler.div(this, x);
        };
        Tensor.prototype.floorDiv = function (x) {
            this.throwIfDisposed();
            return opHandler.floorDiv(this, x);
        };
        Tensor.prototype.divStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.divStrict(this, x);
        };
        Tensor.prototype.minimum = function (x) {
            this.throwIfDisposed();
            return opHandler.minimum(this, x);
        };
        Tensor.prototype.minimumStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.minimumStrict(this, x);
        };
        Tensor.prototype.maximum = function (x) {
            this.throwIfDisposed();
            return opHandler.maximum(this, x);
        };
        Tensor.prototype.maximumStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.maximumStrict(this, x);
        };
        Tensor.prototype.mod = function (x) {
            this.throwIfDisposed();
            return opHandler.mod(this, x);
        };
        Tensor.prototype.modStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.modStrict(this, x);
        };
        Tensor.prototype.squaredDifference = function (x) {
            this.throwIfDisposed();
            return opHandler.squaredDifference(this, x);
        };
        Tensor.prototype.squaredDifferenceStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.squaredDifferenceStrict(this, x);
        };
        Tensor.prototype.transpose = function (perm) {
            this.throwIfDisposed();
            return opHandler.transpose(this, perm);
        };
        // Compare ops.
        Tensor.prototype.notEqual = function (x) {
            this.throwIfDisposed();
            return opHandler.notEqual(this, x);
        };
        Tensor.prototype.notEqualStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.notEqualStrict(this, x);
        };
        Tensor.prototype.less = function (x) {
            this.throwIfDisposed();
            return opHandler.less(this, x);
        };
        Tensor.prototype.lessStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.lessStrict(this, x);
        };
        Tensor.prototype.equal = function (x) {
            this.throwIfDisposed();
            return opHandler.equal(this, x);
        };
        Tensor.prototype.equalStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.equalStrict(this, x);
        };
        Tensor.prototype.lessEqual = function (x) {
            this.throwIfDisposed();
            return opHandler.lessEqual(this, x);
        };
        Tensor.prototype.lessEqualStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.lessEqualStrict(this, x);
        };
        Tensor.prototype.greater = function (x) {
            this.throwIfDisposed();
            return opHandler.greater(this, x);
        };
        Tensor.prototype.greaterStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.greaterStrict(this, x);
        };
        Tensor.prototype.greaterEqual = function (x) {
            this.throwIfDisposed();
            return opHandler.greaterEqual(this, x);
        };
        Tensor.prototype.greaterEqualStrict = function (x) {
            this.throwIfDisposed();
            return opHandler.greaterEqualStrict(this, x);
        };
        // Compare ops.
        Tensor.prototype.logicalAnd = function (x) {
            this.throwIfDisposed();
            return opHandler.logicalAnd(this, x);
        };
        Tensor.prototype.logicalOr = function (x) {
            this.throwIfDisposed();
            return opHandler.logicalOr(this, x);
        };
        Tensor.prototype.logicalNot = function () {
            this.throwIfDisposed();
            return opHandler.logicalNot(this);
        };
        Tensor.prototype.logicalXor = function (x) {
            this.throwIfDisposed();
            return opHandler.logicalXor(this, x);
        };
        Tensor.prototype.where = function (condition, x) {
            this.throwIfDisposed();
            return opHandler.where(condition, this, x);
        };
        // Unary ops.
        Tensor.prototype.neg = function () {
            this.throwIfDisposed();
            return opHandler.neg(this);
        };
        Tensor.prototype.ceil = function () {
            this.throwIfDisposed();
            return opHandler.ceil(this);
        };
        Tensor.prototype.floor = function () {
            this.throwIfDisposed();
            return opHandler.floor(this);
        };
        Tensor.prototype.sign = function () {
            this.throwIfDisposed();
            return opHandler.sign(this);
        };
        Tensor.prototype.exp = function () {
            this.throwIfDisposed();
            return opHandler.exp(this);
        };
        Tensor.prototype.expm1 = function () {
            this.throwIfDisposed();
            return opHandler.expm1(this);
        };
        Tensor.prototype.log = function () {
            this.throwIfDisposed();
            return opHandler.log(this);
        };
        Tensor.prototype.log1p = function () {
            this.throwIfDisposed();
            return opHandler.log1p(this);
        };
        Tensor.prototype.sqrt = function () {
            this.throwIfDisposed();
            return opHandler.sqrt(this);
        };
        Tensor.prototype.rsqrt = function () {
            this.throwIfDisposed();
            return opHandler.rsqrt(this);
        };
        Tensor.prototype.square = function () {
            this.throwIfDisposed();
            return opHandler.square(this);
        };
        Tensor.prototype.reciprocal = function () {
            this.throwIfDisposed();
            return opHandler.reciprocal(this);
        };
        Tensor.prototype.abs = function () {
            this.throwIfDisposed();
            return opHandler.abs(this);
        };
        Tensor.prototype.clipByValue = function (min, max) {
            this.throwIfDisposed();
            return opHandler.clipByValue(this, min, max);
        };
        Tensor.prototype.relu = function () {
            this.throwIfDisposed();
            return opHandler.relu(this);
        };
        Tensor.prototype.elu = function () {
            this.throwIfDisposed();
            return opHandler.elu(this);
        };
        Tensor.prototype.selu = function () {
            this.throwIfDisposed();
            return opHandler.selu(this);
        };
        Tensor.prototype.leakyRelu = function (alpha) {
            if (alpha === void 0) { alpha = 0.2; }
            this.throwIfDisposed();
            return opHandler.leakyRelu(this, alpha);
        };
        Tensor.prototype.prelu = function (alpha) {
            this.throwIfDisposed();
            return opHandler.prelu(this, alpha);
        };
        Tensor.prototype.sigmoid = function () {
            this.throwIfDisposed();
            return opHandler.sigmoid(this);
        };
        Tensor.prototype.logSigmoid = function () {
            this.throwIfDisposed();
            return opHandler.logSigmoid(this);
        };
        Tensor.prototype.softplus = function () {
            this.throwIfDisposed();
            return opHandler.softplus(this);
        };
        Tensor.prototype.zerosLike = function () {
            this.throwIfDisposed();
            return opHandler.zerosLike(this);
        };
        Tensor.prototype.onesLike = function () {
            this.throwIfDisposed();
            return opHandler.onesLike(this);
        };
        Tensor.prototype.sin = function () {
            this.throwIfDisposed();
            return opHandler.sin(this);
        };
        Tensor.prototype.cos = function () {
            this.throwIfDisposed();
            return opHandler.cos(this);
        };
        Tensor.prototype.tan = function () {
            this.throwIfDisposed();
            return opHandler.tan(this);
        };
        Tensor.prototype.asin = function () {
            this.throwIfDisposed();
            return opHandler.asin(this);
        };
        Tensor.prototype.acos = function () {
            this.throwIfDisposed();
            return opHandler.acos(this);
        };
        Tensor.prototype.atan = function () {
            this.throwIfDisposed();
            return opHandler.atan(this);
        };
        Tensor.prototype.sinh = function () {
            this.throwIfDisposed();
            return opHandler.sinh(this);
        };
        Tensor.prototype.cosh = function () {
            this.throwIfDisposed();
            return opHandler.cosh(this);
        };
        Tensor.prototype.tanh = function () {
            this.throwIfDisposed();
            return opHandler.tanh(this);
        };
        Tensor.prototype.asinh = function () {
            this.throwIfDisposed();
            return opHandler.asinh(this);
        };
        Tensor.prototype.acosh = function () {
            this.throwIfDisposed();
            return opHandler.acosh(this);
        };
        Tensor.prototype.atanh = function () {
            this.throwIfDisposed();
            return opHandler.atanh(this);
        };
        Tensor.prototype.erf = function () {
            this.throwIfDisposed();
            return opHandler.erf(this);
        };
        Tensor.prototype.round = function () {
            this.throwIfDisposed();
            return opHandler.round(this);
        };
        Tensor.prototype.step = function (alpha) {
            if (alpha === void 0) { alpha = 0.0; }
            this.throwIfDisposed();
            return opHandler.step(this, alpha);
        };
        Tensor.prototype.softmax = function (dim) {
            if (dim === void 0) { dim = -1; }
            this.throwIfDisposed();
            return opHandler.softmax(this, dim);
        };
        Tensor.prototype.logSoftmax = function (axis) {
            if (axis === void 0) { axis = -1; }
            this.throwIfDisposed();
            return opHandler.logSoftmax(this, axis);
        };
        // Image ops.
        Tensor.prototype.resizeBilinear = function (newShape2D, alignCorners) {
            if (alignCorners === void 0) { alignCorners = false; }
            this.throwIfDisposed();
            return opHandler.image.resizeBilinear(this, newShape2D, alignCorners);
        };
        Tensor.prototype.resizeNearestNeighbor = function (newShape2D, alignCorners) {
            if (alignCorners === void 0) { alignCorners = false; }
            this.throwIfDisposed();
            return opHandler.image.resizeNearestNeighbor(this, newShape2D, alignCorners);
        };
        // Convolutions.
        Tensor.prototype.conv1d = function (filter, stride, pad, dataFormat, dilation, dimRoundingMode) {
            if (dataFormat === void 0) { dataFormat = 'NWC'; }
            if (dilation === void 0) { dilation = 1; }
            this.throwIfDisposed();
            return opHandler.conv1d(this, filter, stride, pad, dataFormat, dilation, dimRoundingMode);
        };
        Tensor.prototype.conv2d = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
            if (dataFormat === void 0) { dataFormat = 'NHWC'; }
            if (dilations === void 0) { dilations = [1, 1]; }
            this.throwIfDisposed();
            return opHandler.conv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
        };
        Tensor.prototype.conv2dTranspose = function (filter, outputShape, strides, pad, dimRoundingMode) {
            this.throwIfDisposed();
            return opHandler.conv2dTranspose(this, filter, outputShape, strides, pad, dimRoundingMode);
        };
        Tensor.prototype.depthwiseConv2D = function (filter, strides, pad, dataFormat, dilations, dimRoundingMode) {
            if (dataFormat === void 0) { dataFormat = 'NHWC'; }
            if (dilations === void 0) { dilations = [1, 1]; }
            this.throwIfDisposed();
            return opHandler.depthwiseConv2d(this, filter, strides, pad, dataFormat, dilations, dimRoundingMode);
        };
        Tensor.prototype.separableConv2d = function (depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat) {
            if (dilation === void 0) { dilation = [1, 1]; }
            if (dataFormat === void 0) { dataFormat = 'NHWC'; }
            this.throwIfDisposed();
            return opHandler.separableConv2d(this, depthwiseFilter, pointwiseFilter, strides, pad, dilation, dataFormat);
        };
        // Pooling.
        Tensor.prototype.avgPool = function (filterSize, strides, pad, dimRoundingMode) {
            this.throwIfDisposed();
            return opHandler.avgPool(this, filterSize, strides, pad, dimRoundingMode);
        };
        Tensor.prototype.maxPool = function (filterSize, strides, pad, dimRoundingMode) {
            this.throwIfDisposed();
            return opHandler.maxPool(this, filterSize, strides, pad, dimRoundingMode);
        };
        Tensor.prototype.localResponseNormalization = function (radius, bias, alpha, beta) {
            if (radius === void 0) { radius = 5; }
            if (bias === void 0) { bias = 1; }
            if (alpha === void 0) { alpha = 1; }
            if (beta === void 0) { beta = 0.5; }
            return opHandler.localResponseNormalization(this, radius, bias, alpha, beta);
        };
        Tensor.prototype.pool = function (windowShape, poolingType, padding, dilationRate, strides) {
            this.throwIfDisposed();
            return opHandler.pool(this, windowShape, poolingType, padding, dilationRate, strides);
        };
        Tensor.prototype.variable = function (trainable, name, dtype) {
            if (trainable === void 0) { trainable = true; }
            this.throwIfDisposed();
            return Variable.variable(this, trainable, name, dtype);
        };
        Tensor.prototype.unsortedSegmentSum = function (segmentIds, numSegments) {
            this.throwIfDisposed();
            return opHandler.unsortedSegmentSum(this, segmentIds, numSegments);
        };
        Tensor.prototype.batchToSpaceND = function (blockShape, crops) {
            this.throwIfDisposed();
            return opHandler.batchToSpaceND(this, blockShape, crops);
        };
        Tensor.prototype.spaceToBatchND = function (blockShape, paddings) {
            this.throwIfDisposed();
            return opHandler.spaceToBatchND(this, blockShape, paddings);
        };
        Tensor.prototype.topk = function (k, sorted) {
            if (k === void 0) { k = 1; }
            if (sorted === void 0) { sorted = true; }
            this.throwIfDisposed();
            return opHandler.topk(this, k, sorted);
        };
        Tensor.prototype.stridedSlice = function (begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask) {
            if (beginMask === void 0) { beginMask = 0; }
            if (endMask === void 0) { endMask = 0; }
            if (ellipsisMask === void 0) { ellipsisMask = 0; }
            if (newAxisMask === void 0) { newAxisMask = 0; }
            if (shrinkAxisMask === void 0) { shrinkAxisMask = 0; }
            this.throwIfDisposed();
            return opHandler.stridedSlice(this, begin, end, strides, beginMask, endMask, ellipsisMask, newAxisMask, shrinkAxisMask);
        };
        Tensor.prototype.depthToSpace = function (blockSize, dataFormat) {
            this.throwIfDisposed();
            return opHandler.depthToSpace(this, blockSize, dataFormat);
        };
        Tensor.prototype.fft = function () {
            this.throwIfDisposed();
            return opHandler.spectral.fft(this);
        };
        Tensor.prototype.ifft = function () {
            this.throwIfDisposed();
            return opHandler.spectral.ifft(this);
        };
        Tensor.prototype.rfft = function () {
            this.throwIfDisposed();
            return opHandler.spectral.rfft(this);
        };
        Tensor.prototype.irfft = function () {
            this.throwIfDisposed();
            return opHandler.spectral.irfft(this);
        };
        return Tensor;
    }());
    exports.Tensor = Tensor;
    Object.defineProperty(Tensor, Symbol.hasInstance, {
        value: function (instance) {
            return !!instance && instance.dataId != null && instance.shape != null &&
                instance.dtype != null;
        }
    });
    /**
     * A mutable `tf.Tensor`, useful for persisting state, e.g. for training.
     */
    /** @doc {heading: 'Tensors', subheading: 'Classes'} */
    var Variable = /** @class */ (function (_super) {
        __extends(Variable, _super);
        /**
         * Private constructor since we cannot add logic before calling `super()`.
         * Instead, we expose static `Variable.variable` method below, which will be
         * added to global namespace.
         */
        function Variable(initialValue, trainable, name) {
            if (trainable === void 0) { trainable = true; }
            var _this = _super.call(this, initialValue.shape, initialValue.dtype, null /* values */, initialValue.dataId) || this;
            _this.trainable = trainable;
            _this.name = name;
            if (_this.name == null) {
                _this.name = trackerFn().nextVariableId().toString();
            }
            try {
                trackerFn().registerVariable(_this);
            }
            catch (ex) {
                trackerFn().disposeTensor(_this);
                throw ex;
            }
            return _this;
        }
        /**
         * Creates a new variable with the provided initial value.
         * ```js
         * const x = tf.variable(tf.tensor([1, 2, 3]));
         * x.assign(tf.tensor([4, 5, 6]));
         *
         * x.print();
         * ```
         *
         * @param initialValue Initial value for the tensor.
         * @param trainable If true, optimizers are allowed to update it.
         * @param name Name of the variable. Defaults to a unique id.
         * @param dtype If set, initialValue will be converted to the given type.
         */
        /** @doc {heading: 'Tensors', subheading: 'Creation'} */
        Variable.variable = function (initialValue, trainable, name, dtype) {
            if (trainable === void 0) { trainable = true; }
            if (dtype != null && dtype !== initialValue.dtype) {
                initialValue = initialValue.asType(dtype);
            }
            return new Variable(initialValue, trainable, name);
        };
        /**
         * Assign a new `tf.Tensor` to this variable. The new `tf.Tensor` must have
         * the same shape and dtype as the old `tf.Tensor`.
         *
         * @param newValue New tensor to be assigned to this variable.
         */
        /** @doc {heading: 'Tensors', subheading: 'Classes'} */
        Variable.prototype.assign = function (newValue) {
            if (newValue.dtype !== this.dtype) {
                throw new Error("dtype of the new value (" + newValue.dtype + ") and " +
                    ("previous value (" + this.dtype + ") must match"));
            }
            if (!util.arraysEqual(newValue.shape, this.shape)) {
                throw new Error("shape of the new value (" + newValue.shape + ") and " +
                    ("previous value (" + this.shape + ") must match"));
            }
            trackerFn().disposeTensor(this);
            this.dataId = newValue.dataId;
            trackerFn().registerTensor(this);
        };
        return Variable;
    }(Tensor));
    exports.Variable = Variable;
    Object.defineProperty(Variable, Symbol.hasInstance, {
        value: function (instance) {
            return instance instanceof Tensor && instance.assign != null &&
                instance.assign instanceof Function;
        }
    });
    var variable = Variable.variable;
    exports.variable = variable;

    });

    unwrapExports(tensor);
    var tensor_1 = tensor.TensorBuffer;
    var tensor_2 = tensor.setTensorTracker;
    var tensor_3 = tensor.setOpHandler;
    var tensor_4 = tensor.setDeprecationWarningFn;
    var tensor_5 = tensor.Tensor;
    var tensor_6 = tensor.Variable;
    var tensor_7 = tensor.variable;

    var types = createCommonjsModule(function (module, exports) {
    /**
     * @license
     * Copyright 2017 Google Inc. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Object.defineProperty(exports, "__esModule", { value: true });
    var Rank;
    (function (Rank) {
        Rank["R0"] = "R0";
        Rank["R1"] = "R1";
        Rank["R2"] = "R2";
        Rank["R3"] = "R3";
        Rank["R4"] = "R4";
        Rank["R5"] = "R5";
        Rank["R6"] = "R6";
    })(Rank = exports.Rank || (exports.Rank = {}));
    // Looks for upcasting types. Used, for example, in operations with mixed dtype
    // inputs.
    var UpcastInt32AndMap;
    (function (UpcastInt32AndMap) {
        UpcastInt32AndMap["float32"] = "float32";
        UpcastInt32AndMap["int32"] = "int32";
        UpcastInt32AndMap["bool"] = "int32";
        UpcastInt32AndMap["complex64"] = "complex64";
    })(UpcastInt32AndMap || (UpcastInt32AndMap = {}));
    var UpcastBoolAndMap;
    (function (UpcastBoolAndMap) {
        UpcastBoolAndMap["float32"] = "float32";
        UpcastBoolAndMap["int32"] = "int32";
        UpcastBoolAndMap["bool"] = "bool";
        UpcastBoolAndMap["complex64"] = "complex64";
    })(UpcastBoolAndMap || (UpcastBoolAndMap = {}));
    var UpcastFloat32AndMap;
    (function (UpcastFloat32AndMap) {
        UpcastFloat32AndMap["float32"] = "float32";
        UpcastFloat32AndMap["int32"] = "float32";
        UpcastFloat32AndMap["bool"] = "float32";
        UpcastFloat32AndMap["complex64"] = "complex64";
    })(UpcastFloat32AndMap || (UpcastFloat32AndMap = {}));
    var UpcastComplex64AndMap;
    (function (UpcastComplex64AndMap) {
        UpcastComplex64AndMap["float32"] = "complex64";
        UpcastComplex64AndMap["int32"] = "complex64";
        UpcastComplex64AndMap["bool"] = "complex64";
        UpcastComplex64AndMap["complex64"] = "complex64";
    })(UpcastComplex64AndMap || (UpcastComplex64AndMap = {}));
    var upcastTypeMap = {
        'float32': UpcastFloat32AndMap,
        'int32': UpcastInt32AndMap,
        'bool': UpcastBoolAndMap,
        'complex64': UpcastComplex64AndMap
    };
    function upcastType(typeA, typeB) {
        if (typeA === 'string' || typeB === 'string') {
            if (typeA === 'string' && typeB === 'string') {
                return 'string';
            }
            throw new Error("Can not upcast " + typeA + " with " + typeB);
        }
        return upcastTypeMap[typeA][typeB];
    }
    exports.upcastType = upcastType;
    /** Returns the output type after summation. */
    function sumOutType(type) {
        return upcastType(type, 'int32');
    }
    exports.sumOutType = sumOutType;

    });

    unwrapExports(types);
    var types_1 = types.Rank;
    var types_2 = types.upcastType;
    var types_3 = types.sumOutType;

    var tensor_util = createCommonjsModule(function (module, exports) {
    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */
    Object.defineProperty(exports, "__esModule", { value: true });



    function makeTypesMatch(a, b) {
        if (a.dtype === b.dtype) {
            return [a, b];
        }
        var dtype = types.upcastType(a.dtype, b.dtype);
        return [a.cast(dtype), b.cast(dtype)];
    }
    exports.makeTypesMatch = makeTypesMatch;
    function assertTypesMatch(a, b) {
        util.assert(a.dtype === b.dtype, function () { return "The dtypes of the first(" + a.dtype + ") and" +
            (" second(" + b.dtype + ") input must match"); });
    }
    exports.assertTypesMatch = assertTypesMatch;
    function isTensorInList(tensor$$1, tensorList) {
        for (var i = 0; i < tensorList.length; i++) {
            if (tensorList[i].id === tensor$$1.id) {
                return true;
            }
        }
        return false;
    }
    exports.isTensorInList = isTensorInList;
    function flattenNameArrayMap(nameArrayMap, keys) {
        var xs = [];
        if (nameArrayMap instanceof tensor.Tensor) {
            xs.push(nameArrayMap);
        }
        else {
            var xMap = nameArrayMap;
            for (var i = 0; i < keys.length; i++) {
                xs.push(xMap[keys[i]]);
            }
        }
        return xs;
    }
    exports.flattenNameArrayMap = flattenNameArrayMap;
    function unflattenToNameArrayMap(keys, flatArrays) {
        if (keys.length !== flatArrays.length) {
            throw new Error("Cannot unflatten Tensor[], keys and arrays are not of same length.");
        }
        var result = {};
        for (var i = 0; i < keys.length; i++) {
            result[keys[i]] = flatArrays[i];
        }
        return result;
    }
    exports.unflattenToNameArrayMap = unflattenToNameArrayMap;
    /**
     * Extracts any `Tensor`s found within the provided object.
     *
     * @param container an object that may be a `Tensor` or may directly contain
     *   `Tensor`s, such as a `Tensor[]` or `{key: Tensor, ...}`. In general it
     *   is safe to pass any object here, except that `Promise`s are not
     *   supported.
     * @returns An array of `Tensors` found within the passed object. If the
     *   argument is simply a `Tensor', a list containing that `Tensor` is
     *   returned. If the object is not a `Tensor` or does not
     *   contain `Tensors`, an empty list is returned.
     */
    function getTensorsInContainer(result) {
        var list = [];
        var seen = new Set();
        walkTensorContainer(result, list, seen);
        return list;
    }
    exports.getTensorsInContainer = getTensorsInContainer;
    function walkTensorContainer(container, list, seen) {
        if (container == null) {
            return;
        }
        if (container instanceof tensor.Tensor) {
            list.push(container);
            return;
        }
        if (!isIterable(container)) {
            return;
        }
        // Iteration over keys works also for arrays.
        var iterable = container;
        for (var k in iterable) {
            var val = iterable[k];
            if (!seen.has(val)) {
                seen.add(val);
                walkTensorContainer(val, list, seen);
            }
        }
    }
    // tslint:disable-next-line:no-any
    function isIterable(obj) {
        return Array.isArray(obj) || typeof obj === 'object';
    }

    });

    unwrapExports(tensor_util);
    var tensor_util_1 = tensor_util.makeTypesMatch;
    var tensor_util_2 = tensor_util.assertTypesMatch;
    var tensor_util_3 = tensor_util.isTensorInList;
    var tensor_util_4 = tensor_util.flattenNameArrayMap;
    var tensor_util_5 = tensor_util.unflattenToNameArrayMap;
    var tensor_util_6 = tensor_util.getTensorsInContainer;

    var isBuffer = function isBuffer(arg) {
      return arg instanceof Buffer;
    };

    var inherits_browser = createCommonjsModule(function (module) {
    if (typeof Object.create === 'function') {
      // implementation from standard node.js 'util' module
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      };
    } else {
      // old school shim for old browsers
      module.exports = function inherits(ctor, superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function () {};
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      };
    }
    });

    var inherits = createCommonjsModule(function (module) {
    try {
      var util = util$2;
      if (typeof util.inherits !== 'function') throw '';
      module.exports = util.inherits;
    } catch (e) {
      module.exports = inherits_browser;
    }
    });

    var util$2 = createCommonjsModule(function (module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors ||
      function getOwnPropertyDescriptors(obj) {
        var keys = Object.keys(obj);
        var descriptors = {};
        for (var i = 0; i < keys.length; i++) {
          descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
        }
        return descriptors;
      };

    var formatRegExp = /%[sdj%]/g;
    exports.format = function(f) {
      if (!isString(f)) {
        var objects = [];
        for (var i = 0; i < arguments.length; i++) {
          objects.push(inspect(arguments[i]));
        }
        return objects.join(' ');
      }

      var i = 1;
      var args = arguments;
      var len = args.length;
      var str = String(f).replace(formatRegExp, function(x) {
        if (x === '%%') return '%';
        if (i >= len) return x;
        switch (x) {
          case '%s': return String(args[i++]);
          case '%d': return Number(args[i++]);
          case '%j':
            try {
              return JSON.stringify(args[i++]);
            } catch (_) {
              return '[Circular]';
            }
          default:
            return x;
        }
      });
      for (var x = args[i]; i < len; x = args[++i]) {
        if (isNull(x) || !isObject(x)) {
          str += ' ' + x;
        } else {
          str += ' ' + inspect(x);
        }
      }
      return str;
    };


    // Mark that a method should not be used.
    // Returns a modified function which warns once by default.
    // If --no-deprecation is set, then it is a no-op.
    exports.deprecate = function(fn, msg) {
      if (typeof process !== 'undefined' && process.noDeprecation === true) {
        return fn;
      }

      // Allow for deprecating things in the process of starting up.
      if (typeof process === 'undefined') {
        return function() {
          return exports.deprecate(fn, msg).apply(this, arguments);
        };
      }

      var warned = false;
      function deprecated() {
        if (!warned) {
          if (process.throwDeprecation) {
            throw new Error(msg);
          } else if (process.traceDeprecation) {
            console.trace(msg);
          } else {
            console.error(msg);
          }
          warned = true;
        }
        return fn.apply(this, arguments);
      }

      return deprecated;
    };


    var debugs = {};
    var debugEnviron;
    exports.debuglog = function(set) {
      if (isUndefined(debugEnviron))
        debugEnviron = process.env.NODE_DEBUG || '';
      set = set.toUpperCase();
      if (!debugs[set]) {
        if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
          var pid = process.pid;
          debugs[set] = function() {
            var msg = exports.format.apply(exports, arguments);
            console.error('%s %d: %s', set, pid, msg);
          };
        } else {
          debugs[set] = function() {};
        }
      }
      return debugs[set];
    };


    /**
     * Echos the value of a value. Trys to print the value out
     * in the best way possible given the different types.
     *
     * @param {Object} obj The object to print out.
     * @param {Object} opts Optional options object that alters the output.
     */
    /* legacy: obj, showHidden, depth, colors*/
    function inspect(obj, opts) {
      // default options
      var ctx = {
        seen: [],
        stylize: stylizeNoColor
      };
      // legacy...
      if (arguments.length >= 3) ctx.depth = arguments[2];
      if (arguments.length >= 4) ctx.colors = arguments[3];
      if (isBoolean(opts)) {
        // legacy...
        ctx.showHidden = opts;
      } else if (opts) {
        // got an "options" object
        exports._extend(ctx, opts);
      }
      // set default options
      if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
      if (isUndefined(ctx.depth)) ctx.depth = 2;
      if (isUndefined(ctx.colors)) ctx.colors = false;
      if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
      if (ctx.colors) ctx.stylize = stylizeWithColor;
      return formatValue(ctx, obj, ctx.depth);
    }
    exports.inspect = inspect;


    // http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
    inspect.colors = {
      'bold' : [1, 22],
      'italic' : [3, 23],
      'underline' : [4, 24],
      'inverse' : [7, 27],
      'white' : [37, 39],
      'grey' : [90, 39],
      'black' : [30, 39],
      'blue' : [34, 39],
      'cyan' : [36, 39],
      'green' : [32, 39],
      'magenta' : [35, 39],
      'red' : [31, 39],
      'yellow' : [33, 39]
    };

    // Don't use 'blue' not visible on cmd.exe
    inspect.styles = {
      'special': 'cyan',
      'number': 'yellow',
      'boolean': 'yellow',
      'undefined': 'grey',
      'null': 'bold',
      'string': 'green',
      'date': 'magenta',
      // "name": intentionally not styling
      'regexp': 'red'
    };


    function stylizeWithColor(str, styleType) {
      var style = inspect.styles[styleType];

      if (style) {
        return '\u001b[' + inspect.colors[style][0] + 'm' + str +
               '\u001b[' + inspect.colors[style][1] + 'm';
      } else {
        return str;
      }
    }


    function stylizeNoColor(str, styleType) {
      return str;
    }


    function arrayToHash(array) {
      var hash = {};

      array.forEach(function(val, idx) {
        hash[val] = true;
      });

      return hash;
    }


    function formatValue(ctx, value, recurseTimes) {
      // Provide a hook for user-specified inspect functions.
      // Check that value is an object with an inspect function on it
      if (ctx.customInspect &&
          value &&
          isFunction(value.inspect) &&
          // Filter out the util module, it's inspect function is special
          value.inspect !== exports.inspect &&
          // Also filter out any prototype objects using the circular check.
          !(value.constructor && value.constructor.prototype === value)) {
        var ret = value.inspect(recurseTimes, ctx);
        if (!isString(ret)) {
          ret = formatValue(ctx, ret, recurseTimes);
        }
        return ret;
      }

      // Primitive types cannot have properties
      var primitive = formatPrimitive(ctx, value);
      if (primitive) {
        return primitive;
      }

      // Look up the keys of the object.
      var keys = Object.keys(value);
      var visibleKeys = arrayToHash(keys);

      if (ctx.showHidden) {
        keys = Object.getOwnPropertyNames(value);
      }

      // IE doesn't make error fields non-enumerable
      // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
      if (isError(value)
          && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
        return formatError(value);
      }

      // Some type of object without properties can be shortcutted.
      if (keys.length === 0) {
        if (isFunction(value)) {
          var name = value.name ? ': ' + value.name : '';
          return ctx.stylize('[Function' + name + ']', 'special');
        }
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        }
        if (isDate(value)) {
          return ctx.stylize(Date.prototype.toString.call(value), 'date');
        }
        if (isError(value)) {
          return formatError(value);
        }
      }

      var base = '', array = false, braces = ['{', '}'];

      // Make Array say that they are Array
      if (isArray(value)) {
        array = true;
        braces = ['[', ']'];
      }

      // Make functions say that they are functions
      if (isFunction(value)) {
        var n = value.name ? ': ' + value.name : '';
        base = ' [Function' + n + ']';
      }

      // Make RegExps say that they are RegExps
      if (isRegExp(value)) {
        base = ' ' + RegExp.prototype.toString.call(value);
      }

      // Make dates with properties first say the date
      if (isDate(value)) {
        base = ' ' + Date.prototype.toUTCString.call(value);
      }

      // Make error with message first say the error
      if (isError(value)) {
        base = ' ' + formatError(value);
      }

      if (keys.length === 0 && (!array || value.length == 0)) {
        return braces[0] + base + braces[1];
      }

      if (recurseTimes < 0) {
        if (isRegExp(value)) {
          return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
        } else {
          return ctx.stylize('[Object]', 'special');
        }
      }

      ctx.seen.push(value);

      var output;
      if (array) {
        output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
      } else {
        output = keys.map(function(key) {
          return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
        });
      }

      ctx.seen.pop();

      return reduceToSingleString(output, base, braces);
    }


    function formatPrimitive(ctx, value) {
      if (isUndefined(value))
        return ctx.stylize('undefined', 'undefined');
      if (isString(value)) {
        var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                                 .replace(/'/g, "\\'")
                                                 .replace(/\\"/g, '"') + '\'';
        return ctx.stylize(simple, 'string');
      }
      if (isNumber(value))
        return ctx.stylize('' + value, 'number');
      if (isBoolean(value))
        return ctx.stylize('' + value, 'boolean');
      // For some reason typeof null is "object", so special case here.
      if (isNull(value))
        return ctx.stylize('null', 'null');
    }


    function formatError(value) {
      return '[' + Error.prototype.toString.call(value) + ']';
    }


    function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
      var output = [];
      for (var i = 0, l = value.length; i < l; ++i) {
        if (hasOwnProperty(value, String(i))) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              String(i), true));
        } else {
          output.push('');
        }
      }
      keys.forEach(function(key) {
        if (!key.match(/^\d+$/)) {
          output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
              key, true));
        }
      });
      return output;
    }


    function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
      var name, str, desc;
      desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
      if (desc.get) {
        if (desc.set) {
          str = ctx.stylize('[Getter/Setter]', 'special');
        } else {
          str = ctx.stylize('[Getter]', 'special');
        }
      } else {
        if (desc.set) {
          str = ctx.stylize('[Setter]', 'special');
        }
      }
      if (!hasOwnProperty(visibleKeys, key)) {
        name = '[' + key + ']';
      }
      if (!str) {
        if (ctx.seen.indexOf(desc.value) < 0) {
          if (isNull(recurseTimes)) {
            str = formatValue(ctx, desc.value, null);
          } else {
            str = formatValue(ctx, desc.value, recurseTimes - 1);
          }
          if (str.indexOf('\n') > -1) {
            if (array) {
              str = str.split('\n').map(function(line) {
                return '  ' + line;
              }).join('\n').substr(2);
            } else {
              str = '\n' + str.split('\n').map(function(line) {
                return '   ' + line;
              }).join('\n');
            }
          }
        } else {
          str = ctx.stylize('[Circular]', 'special');
        }
      }
      if (isUndefined(name)) {
        if (array && key.match(/^\d+$/)) {
          return str;
        }
        name = JSON.stringify('' + key);
        if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
          name = name.substr(1, name.length - 2);
          name = ctx.stylize(name, 'name');
        } else {
          name = name.replace(/'/g, "\\'")
                     .replace(/\\"/g, '"')
                     .replace(/(^"|"$)/g, "'");
          name = ctx.stylize(name, 'string');
        }
      }

      return name + ': ' + str;
    }


    function reduceToSingleString(output, base, braces) {
      var length = output.reduce(function(prev, cur) {
        if (cur.indexOf('\n') >= 0) ;
        return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
      }, 0);

      if (length > 60) {
        return braces[0] +
               (base === '' ? '' : base + '\n ') +
               ' ' +
               output.join(',\n  ') +
               ' ' +
               braces[1];
      }

      return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
    }


    // NOTE: These type checking functions intentionally don't use `instanceof`
    // because it is fragile and can be easily faked with `Object.create()`.
    function isArray(ar) {
      return Array.isArray(ar);
    }
    exports.isArray = isArray;

    function isBoolean(arg) {
      return typeof arg === 'boolean';
    }
    exports.isBoolean = isBoolean;

    function isNull(arg) {
      return arg === null;
    }
    exports.isNull = isNull;

    function isNullOrUndefined(arg) {
      return arg == null;
    }
    exports.isNullOrUndefined = isNullOrUndefined;

    function isNumber(arg) {
      return typeof arg === 'number';
    }
    exports.isNumber = isNumber;

    function isString(arg) {
      return typeof arg === 'string';
    }
    exports.isString = isString;

    function isSymbol(arg) {
      return typeof arg === 'symbol';
    }
    exports.isSymbol = isSymbol;

    function isUndefined(arg) {
      return arg === void 0;
    }
    exports.isUndefined = isUndefined;

    function isRegExp(re) {
      return isObject(re) && objectToString(re) === '[object RegExp]';
    }
    exports.isRegExp = isRegExp;

    function isObject(arg) {
      return typeof arg === 'object' && arg !== null;
    }
    exports.isObject = isObject;

    function isDate(d) {
      return isObject(d) && objectToString(d) === '[object Date]';
    }
    exports.isDate = isDate;

    function isError(e) {
      return isObject(e) &&
          (objectToString(e) === '[object Error]' || e instanceof Error);
    }
    exports.isError = isError;

    function isFunction(arg) {
      return typeof arg === 'function';
    }
    exports.isFunction = isFunction;

    function isPrimitive(arg) {
      return arg === null ||
             typeof arg === 'boolean' ||
             typeof arg === 'number' ||
             typeof arg === 'string' ||
             typeof arg === 'symbol' ||  // ES6 symbol
             typeof arg === 'undefined';
    }
    exports.isPrimitive = isPrimitive;

    exports.isBuffer = isBuffer;

    function objectToString(o) {
      return Object.prototype.toString.call(o);
    }


    function pad(n) {
      return n < 10 ? '0' + n.toString(10) : n.toString(10);
    }


    var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
                  'Oct', 'Nov', 'Dec'];

    // 26 Feb 16:19:34
    function timestamp() {
      var d = new Date();
      var time = [pad(d.getHours()),
                  pad(d.getMinutes()),
                  pad(d.getSeconds())].join(':');
      return [d.getDate(), months[d.getMonth()], time].join(' ');
    }


    // log is just a thin wrapper to console.log that prepends a timestamp
    exports.log = function() {
      console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
    };


    /**
     * Inherit the prototype methods from one constructor into another.
     *
     * The Function.prototype.inherits from lang.js rewritten as a standalone
     * function (not on Function.prototype). NOTE: If this file is to be loaded
     * during bootstrapping this function needs to be rewritten using some native
     * functions as prototype setup using normal JavaScript does not work as
     * expected during bootstrapping (see mirror.js in r114903).
     *
     * @param {function} ctor Constructor function which needs to inherit the
     *     prototype.
     * @param {function} superCtor Constructor function to inherit prototype from.
     */
    exports.inherits = inherits;

    exports._extend = function(origin, add) {
      // Don't do anything if add isn't an object
      if (!add || !isObject(add)) return origin;

      var keys = Object.keys(add);
      var i = keys.length;
      while (i--) {
        origin[keys[i]] = add[keys[i]];
      }
      return origin;
    };

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    var kCustomPromisifiedSymbol = typeof Symbol !== 'undefined' ? Symbol('util.promisify.custom') : undefined;

    exports.promisify = function promisify(original) {
      if (typeof original !== 'function')
        throw new TypeError('The "original" argument must be of type Function');

      if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
        var fn = original[kCustomPromisifiedSymbol];
        if (typeof fn !== 'function') {
          throw new TypeError('The "util.promisify.custom" argument must be of type Function');
        }
        Object.defineProperty(fn, kCustomPromisifiedSymbol, {
          value: fn, enumerable: false, writable: false, configurable: true
        });
        return fn;
      }

      function fn() {
        var promiseResolve, promiseReject;
        var promise = new Promise(function (resolve, reject) {
          promiseResolve = resolve;
          promiseReject = reject;
        });

        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }
        args.push(function (err, value) {
          if (err) {
            promiseReject(err);
          } else {
            promiseResolve(value);
          }
        });

        try {
          original.apply(this, args);
        } catch (err) {
          promiseReject(err);
        }

        return promise;
      }

      Object.setPrototypeOf(fn, Object.getPrototypeOf(original));

      if (kCustomPromisifiedSymbol) Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn, enumerable: false, writable: false, configurable: true
      });
      return Object.defineProperties(
        fn,
        getOwnPropertyDescriptors(original)
      );
    };

    exports.promisify.custom = kCustomPromisifiedSymbol;

    function callbackifyOnRejected(reason, cb) {
      // `!reason` guard inspired by bluebird (Ref: https://goo.gl/t5IS6M).
      // Because `null` is a special error value in callbacks which means "no error
      // occurred", we error-wrap so the callback consumer can distinguish between
      // "the promise rejected with null" or "the promise fulfilled with undefined".
      if (!reason) {
        var newReason = new Error('Promise was rejected with a falsy value');
        newReason.reason = reason;
        reason = newReason;
      }
      return cb(reason);
    }

    function callbackify(original) {
      if (typeof original !== 'function') {
        throw new TypeError('The "original" argument must be of type Function');
      }

      // We DO NOT return the promise as it gives the user a false sense that
      // the promise is actually somehow related to the callback's execution
      // and that the callback throwing will reject the promise.
      function callbackified() {
        var args = [];
        for (var i = 0; i < arguments.length; i++) {
          args.push(arguments[i]);
        }

        var maybeCb = args.pop();
        if (typeof maybeCb !== 'function') {
          throw new TypeError('The last argument must be of type Function');
        }
        var self = this;
        var cb = function() {
          return maybeCb.apply(self, arguments);
        };
        // In true node style we process the callback on `nextTick` with all the
        // implications (stack, `uncaughtException`, `async_hooks`)
        original.apply(this, args)
          .then(function(ret) { process.nextTick(cb, null, ret); },
                function(rej) { process.nextTick(callbackifyOnRejected, rej, cb); });
      }

      Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
      Object.defineProperties(callbackified,
                              getOwnPropertyDescriptors(original));
      return callbackified;
    }
    exports.callbackify = callbackify;
    });
    var util_1$1 = util$2.format;
    var util_2$1 = util$2.deprecate;
    var util_3$1 = util$2.debuglog;
    var util_4$1 = util$2.inspect;
    var util_5$1 = util$2.isArray;
    var util_6$1 = util$2.isBoolean;
    var util_7$1 = util$2.isNull;
    var util_8$1 = util$2.isNullOrUndefined;
    var util_9$1 = util$2.isNumber;
    var util_10$1 = util$2.isString;
    var util_11$1 = util$2.isSymbol;
    var util_12$1 = util$2.isUndefined;
    var util_13$1 = util$2.isRegExp;
    var util_14$1 = util$2.isObject;
    var util_15$1 = util$2.isDate;
    var util_16$1 = util$2.isError;
    var util_17$1 = util$2.isFunction;
    var util_18$1 = util$2.isPrimitive;
    var util_19$1 = util$2.isBuffer;
    var util_20$1 = util$2.log;
    var util_21$1 = util$2.inherits;
    var util_22$1 = util$2._extend;
    var util_23$1 = util$2.promisify;
    var util_24$1 = util$2.callbackify;

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /**
     * @param seen: A Map of known object mappings (i.e., memoized results of
     *   `mapFn()`)
     * @param containedIn: An set containing objects on the reference path currently
     *   being processed (used to detect cycles).
     */
    function deepMapInternal(input, mapFn, seen, containedIn) {
        if (seen === void 0) { seen = new Map(); }
        if (containedIn === void 0) { containedIn = new Set(); }
        if (input == null) {
            return null;
        }
        if (containedIn.has(input)) {
            throw new Error('Circular references are not supported.');
        }
        if (seen.has(input)) {
            return seen.get(input);
        }
        var result = mapFn(input);
        if (result.recurse && result.value !== null) {
            throw new Error('A deep map function may not return both a value and recurse=true.');
        }
        if (!result.recurse) {
            seen.set(input, result.value);
            return result.value;
        }
        else if (isIterable(input)) {
            // tslint:disable-next-line:no-any
            var mappedIterable = Array.isArray(input) ? [] : {};
            containedIn.add(input);
            for (var k in input) {
                var child = input[k];
                var childResult = deepMapInternal(child, mapFn, seen, containedIn);
                mappedIterable[k] = childResult;
            }
            containedIn.delete(input);
            return mappedIterable;
        }
        else {
            throw new Error("Can't recurse into non-iterable type: " + input);
        }
    }
    // TODO(soergel, kangyizhang) Reconsider naming of deepZip() to avoid confusion
    // with zip()
    /**
     * Zip nested structures together in a recursive manner.
     *
     * This has the effect of transposing or pivoting data, e.g. converting it from
     * a row-major representation to a column-major representation.
     *
     * For example, `deepZip([{a: 1, b: 2}, {a: 3, b: 4}])` returns
     * `{a: [1, 3], b: [2, 4]}`.
     *
     * The inputs should all have the same nested structure (i.e., of arrays and
     * dicts).  The result is a single object with the same nested structure, where
     * the leaves are arrays collecting the values of the inputs at that location
     * (or, optionally, the result of a custom function applied to those arrays).
     *
     * @param inputs: An array of the objects to zip together.
     * @param zipFn: (optional) A function that expects an array of elements at a
     *   single node of the object tree, and returns a `DeepMapResult`.  The
     *   `DeepMapResult` either provides a result value for that node (i.e.,
     *   representing the subtree), or indicates that the node should be processed
     *   recursively.  The default zipFn recurses as far as possible and places
     *   arrays at the leaves.
     */
    function deepZip(inputs, zipFn) {
        if (zipFn === void 0) { zipFn = zipToList; }
        return deepZipInternal(inputs, zipFn);
    }
    /**
     * @param containedIn: An set containing objects on the reference path currently
     *   being processed (used to detect cycles).
     */
    function deepZipInternal(inputs, zipFn, containedIn) {
        if (containedIn === void 0) { containedIn = new Set(); }
        // The recursion follows the structure of input 0; it's assumed that all the
        // other inputs have the same structure.
        var input = inputs[0];
        if (containedIn.has(input)) {
            throw new Error('Circular references are not supported.');
        }
        var result = zipFn(inputs);
        if (result.recurse && result.value !== null) {
            throw new Error('A deep zip function may not return both a value and recurse=true.');
        }
        if (!result.recurse) {
            return result.value;
        }
        else if (isIterable(input)) {
            // tslint:disable-next-line:no-any
            var mappedIterable = Array.isArray(input) ? [] : {};
            containedIn.add(input);
            var _loop_1 = function (k) {
                var children = inputs.map(function (x) { return x[k]; });
                var childResult = deepZipInternal(children, zipFn, containedIn);
                mappedIterable[k] = childResult;
            };
            for (var k in input) {
                _loop_1(k);
            }
            containedIn.delete(input);
            return mappedIterable;
        }
        else {
            throw new Error("Can't recurse into non-iterable type: " + input);
        }
    }
    // tslint:disable-next-line:no-any
    function zipToList(x) {
        if (x === null) {
            return null;
        }
        // TODO(soergel): validate array type?
        if (isIterable(x[0])) {
            return { value: null, recurse: true };
        }
        else {
            return { value: x, recurse: false };
        }
    }
    /**
     * Apply an async mapping function to a nested structure in a recursive manner.
     *
     * This first creates a nested structure of Promises, and then awaits all of
     * those, resulting in a single Promise for a resolved nested structure.
     *
     * The result of the mapping is an object with the same nested structure (i.e.,
     * of arrays and dicts) as the input, except that some subtrees are replaced,
     * according to the results of the mapping function.
     *
     * Mappings are memoized.  Thus, if the nested structure contains the same
     * object in multiple positions, the output will contain the same mapped object
     * in those positions.  Cycles are not supported, however.
     *
     * @param input: The object to which to apply the mapping function.
     * @param mapFn: A function that expects a single node of the object tree, and
     *   returns a `DeepMapAsyncResult`.  The `DeepMapAsyncResult` either provides
     *   a `Promise` for a replacement value for that node (i.e., replacing the
     *   subtree), or indicates that the node should be processed recursively.  Note
     *   that the decision whether or not to recurse must be made immediately; only
     *   the mapped value may be promised.
     */
    function deepMapAndAwaitAll(input, mapFn) {
        return __awaiter(this, void 0, void 0, function () {
            var seen, _i, _a, key, value, mappedValue, result;
            return __generator(this, function (_b) {
                switch (_b.label) {
                    case 0:
                        seen = new Map();
                        // First do a normal deepMap, collecting Promises in 'seen' as a side effect.
                        deepMapInternal(input, mapFn, seen);
                        _i = 0, _a = Array.from(seen.keys());
                        _b.label = 1;
                    case 1:
                        if (!(_i < _a.length)) return [3 /*break*/, 4];
                        key = _a[_i];
                        value = seen.get(key);
                        if (!(value instanceof Promise)) return [3 /*break*/, 3];
                        return [4 /*yield*/, value];
                    case 2:
                        mappedValue = _b.sent();
                        seen.set(key, mappedValue);
                        _b.label = 3;
                    case 3:
                        _i++;
                        return [3 /*break*/, 1];
                    case 4:
                        result = deepMapInternal(input, mapFn, seen);
                        return [2 /*return*/, result];
                }
            });
        });
    }
    /**
     * Determine whether the argument is iterable.
     *
     * @returns true if the argument is an array or any non-Tensor object.
     */
    // tslint:disable-next-line:no-any
    function isIterable(obj) {
        return obj != null &&
            (Array.isArray(obj) ||
                (typeof obj === 'object' && !(obj instanceof tf.Tensor)));
    }
    /**
     * Determine whether the argument can be converted to Tensor.
     *
     * Tensors, primitives, arrays, and TypedArrays all qualify; anything else does
     * not.
     *
     * @returns true if the argument can be converted to Tensor.
     */
    // tslint:disable-next-line:no-any
    function canTensorify(obj) {
        return obj == null || util_18$1(obj) || Array.isArray(obj) ||
            (typeof obj === 'object' && (obj instanceof tf.Tensor)) ||
            util_28(obj);
    }

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /**
     * A ring buffer, providing O(1) FIFO, LIFO, and related operations.
     */
    var RingBuffer = /** @class */ (function () {
        /**
         * Constructs a `RingBuffer`.
         * @param capacity The number of items that the buffer can accomodate.
         */
        function RingBuffer(capacity) {
            this.capacity = capacity;
            // Note we store the indices in the range 0 <= index < 2*capacity.
            // This allows us to distinguish the full from the empty case.
            // See https://www.snellman.net/blog/archive/2016-12-13-ring-buffers/
            this.begin = 0; // inclusive
            this.end = 0; // exclusive
            if (capacity == null) {
                throw new RangeError('Can\'t create a ring buffer of unknown capacity.');
            }
            if (capacity < 1) {
                throw new RangeError('Can\'t create ring buffer of capacity < 1.');
            }
            this.data = new Array(capacity);
            this.doubledCapacity = 2 * capacity;
        }
        /**
         * Map any index into the range 0 <= index < 2*capacity.
         */
        RingBuffer.prototype.wrap = function (index) {
            // don't trust % on negative numbers
            while (index < 0) {
                index += this.doubledCapacity;
            }
            return index % this.doubledCapacity;
        };
        RingBuffer.prototype.get = function (index) {
            if (index < 0) {
                throw new RangeError('Can\'t get item at a negative index.');
            }
            return this.data[index % this.capacity];
        };
        RingBuffer.prototype.set = function (index, value) {
            if (index < 0) {
                throw new RangeError('Can\'t set item at a negative index.');
            }
            this.data[index % this.capacity] = value;
        };
        /**
         * Returns the current number of items in the buffer.
         */
        RingBuffer.prototype.length = function () {
            var length = this.end - this.begin;
            if (length < 0) {
                length = this.doubledCapacity + length;
            }
            return length;
        };
        /**
         * Reports whether the buffer is full.
         * @returns true if the number of items in the buffer equals its capacity, and
         *   false otherwise.
         */
        RingBuffer.prototype.isFull = function () {
            return this.length() === this.capacity;
        };
        /**
         * Reports whether the buffer is empty.
         * @returns true if the number of items in the buffer equals zero, and
         *   false otherwise.
         */
        RingBuffer.prototype.isEmpty = function () {
            return this.length() === 0;
        };
        /**
         * Adds an item to the end of the buffer.
         */
        RingBuffer.prototype.push = function (value) {
            if (this.isFull()) {
                throw new RangeError('Ring buffer is full.');
            }
            this.set(this.end, value);
            this.end = this.wrap(this.end + 1);
        };
        /**
         * Adds many items to the end of the buffer, in order.
         */
        RingBuffer.prototype.pushAll = function (values) {
            for (var _i = 0, values_1 = values; _i < values_1.length; _i++) {
                var value = values_1[_i];
                this.push(value);
            }
        };
        /**
         * Removes and returns the last item in the buffer.
         */
        RingBuffer.prototype.pop = function () {
            if (this.isEmpty()) {
                throw new RangeError('Ring buffer is empty.');
            }
            this.end = this.wrap(this.end - 1);
            var result = this.get(this.end);
            this.set(this.end, undefined);
            return result;
        };
        /**
         * Adds an item to the beginning of the buffer.
         */
        RingBuffer.prototype.unshift = function (value) {
            if (this.isFull()) {
                throw new RangeError('Ring buffer is full.');
            }
            this.begin = this.wrap(this.begin - 1);
            this.set(this.begin, value);
        };
        /**
         * Removes and returns the first item in the buffer.
         */
        RingBuffer.prototype.shift = function () {
            if (this.isEmpty()) {
                throw new RangeError('Ring buffer is empty.');
            }
            var result = this.get(this.begin);
            this.set(this.begin, undefined);
            this.begin = this.wrap(this.begin + 1);
            return result;
        };
        /**
         * Removes and returns a specific item in the buffer, and moves the last item
         * to the vacated slot.  This is useful for implementing a shuffling stream.
         * Note that this operation necessarily scrambles the original order.
         *
         * @param relativeIndex: the index of the item to remove, relative to the
         *   first item in the buffer (e.g., hiding the ring nature of the underlying
         *   storage).
         */
        RingBuffer.prototype.shuffleExcise = function (relativeIndex) {
            if (this.isEmpty()) {
                throw new RangeError('Ring buffer is empty.');
            }
            var index = this.wrap(this.begin + relativeIndex);
            var result = this.get(index);
            this.set(index, this.pop());
            return result;
        };
        return RingBuffer;
    }());

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    var GrowingRingBuffer = /** @class */ (function (_super) {
        __extends(GrowingRingBuffer, _super);
        /**
         * Constructs a `GrowingRingBuffer`.
         */
        function GrowingRingBuffer() {
            return _super.call(this, GrowingRingBuffer.INITIAL_CAPACITY) || this;
        }
        GrowingRingBuffer.prototype.isFull = function () {
            return false;
        };
        GrowingRingBuffer.prototype.push = function (value) {
            if (_super.prototype.isFull.call(this)) {
                this.expand();
            }
            _super.prototype.push.call(this, value);
        };
        GrowingRingBuffer.prototype.unshift = function (value) {
            if (_super.prototype.isFull.call(this)) {
                this.expand();
            }
            _super.prototype.unshift.call(this, value);
        };
        /**
         * Doubles the capacity of the buffer.
         */
        GrowingRingBuffer.prototype.expand = function () {
            var newCapacity = this.capacity * 2;
            var newData = new Array(newCapacity);
            var len = this.length();
            // Rotate the buffer to start at index 0 again, since we can't just
            // allocate more space at the end.
            for (var i = 0; i < len; i++) {
                newData[i] = this.get(this.wrap(this.begin + i));
            }
            this.data = newData;
            this.capacity = newCapacity;
            this.doubledCapacity = 2 * this.capacity;
            this.begin = 0;
            this.end = len;
        };
        GrowingRingBuffer.INITIAL_CAPACITY = 32;
        return GrowingRingBuffer;
    }(RingBuffer));

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    // Here we implement a simple asynchronous iterator.
    // This lets us avoid using either third-party stream libraries or
    // recent TypeScript language support requiring polyfills.
    /**
     * Create a `LazyIterator` from an array of items.
     */
    function iteratorFromItems(items) {
        return new ArrayIterator(items);
    }
    /**
     * Create a `LazyIterator` from a function.
     *
     * ```js
     * let i = -1;
     * const func = () =>
     *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};
     * const iter = tf.data.iteratorFromFunction(func);
     * await iter.forEachAsync(e => console.log(e));
     * ```
     *
     * @param func A function that produces data on each call.
     */
    function iteratorFromFunction(func) {
        return new FunctionCallIterator(func);
    }
    /**
     * Create a `LazyIterator` by concatenating underlying streams, which are
     * themselves provided as a stream.
     *
     * This can also be thought of as a "stream flatten" operation.
     *
     * @param baseIterators A stream of streams to be concatenated.
     * @param baseErrorHandler An optional function that can intercept `Error`s
     *   raised during a `next()` call on the base stream.  This function can decide
     *   whether the error should be propagated, whether the error should be
     *   ignored, or whether the base stream should be terminated.
     */
    function iteratorFromConcatenated(baseIterators, baseErrorHandler) {
        return new ChainedIterator(baseIterators, baseErrorHandler);
    }
    /**
     * Create a `LazyIterator` by zipping together an array, dict, or nested
     * structure of `LazyIterator`s (and perhaps additional constants).
     *
     * The underlying streams must provide elements in a consistent order such
     * that they correspond.
     *
     * Typically, the underlying streams should have the same number of
     * elements. If they do not, the behavior is determined by the
     * `mismatchMode` argument.
     *
     * The nested structure of the `iterators` argument determines the
     * structure of elements in the resulting iterator.
     *
     * @param iterators: An array or object containing LazyIterators at the
     * leaves.
     * @param mismatchMode: Determines what to do when one underlying iterator
     * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)
     * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`
     * causes the zipped iterator to terminate with the furst underlying
     * streams, so elements remaining on the longer streams are ignored.
     * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling
     * in nulls for the exhausted streams, until all streams are exhausted.
     */
    function iteratorFromZipped(iterators, mismatchMode) {
        if (mismatchMode === void 0) { mismatchMode = ZipMismatchMode.FAIL; }
        return new ZipIterator(iterators, mismatchMode);
    }
    /**
     * An asynchronous iterator, providing lazy access to a potentially
     * unbounded stream of elements.
     *
     * Iterator can be obtained from a dataset:
     * `const iter = await dataset.iterator();`
     */
    var LazyIterator = /** @class */ (function () {
        function LazyIterator() {
        }
        /**
         * Collect all remaining elements of a bounded stream into an array.
         * Obviously this will succeed only for small streams that fit in memory.
         * Useful for testing.
         *
         * @returns A Promise for an array of stream elements, which will resolve
         *   when the stream is exhausted.
         */
        LazyIterator.prototype.toArray = function () {
            return __awaiter(this, void 0, void 0, function () {
                var result, x;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            result = [];
                            return [4 /*yield*/, this.next()];
                        case 1:
                            x = _a.sent();
                            _a.label = 2;
                        case 2:
                            if (!!x.done) return [3 /*break*/, 4];
                            result.push(x.value);
                            return [4 /*yield*/, this.next()];
                        case 3:
                            x = _a.sent();
                            return [3 /*break*/, 2];
                        case 4: return [2 /*return*/, result];
                    }
                });
            });
        };
        /**
         * Collect all elements of this dataset into an array with prefetching 100
         * elements. This is useful for testing, because the prefetch changes the
         * order in which the Promises are resolved along the processing pipeline.
         * This may help expose bugs where results are dependent on the order of
         * Promise resolution rather than on the logical order of the stream (i.e.,
         * due to hidden mutable state).
         *
         * @returns A Promise for an array of stream elements, which will resolve
         *   when the stream is exhausted.
         */
        LazyIterator.prototype.toArrayForTest = function () {
            return __awaiter(this, void 0, void 0, function () {
                var stream, result, x;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            stream = this.prefetch(100);
                            result = [];
                            return [4 /*yield*/, stream.next()];
                        case 1:
                            x = _a.sent();
                            _a.label = 2;
                        case 2:
                            if (!!x.done) return [3 /*break*/, 4];
                            result.push(x.value);
                            return [4 /*yield*/, stream.next()];
                        case 3:
                            x = _a.sent();
                            return [3 /*break*/, 2];
                        case 4: return [2 /*return*/, result];
                    }
                });
            });
        };
        /**
         * Draw items from the stream until it is exhausted.
         *
         * This can be useful when the stream has side effects but no output.  In
         * that case, calling this function guarantees that the stream will be
         * fully processed.
         */
        LazyIterator.prototype.resolveFully = function () {
            return __awaiter(this, void 0, void 0, function () {
                var x;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.next()];
                        case 1:
                            x = _a.sent();
                            _a.label = 2;
                        case 2:
                            if (!!x.done) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.next()];
                        case 3:
                            x = _a.sent();
                            return [3 /*break*/, 2];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Draw items from the stream until it is exhausted, or a predicate fails.
         *
         * This can be useful when the stream has side effects but no output.  In
         * that case, calling this function guarantees that the stream will be
         * fully processed.
         */
        LazyIterator.prototype.resolveWhile = function (predicate) {
            return __awaiter(this, void 0, void 0, function () {
                var x, shouldContinue;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.next()];
                        case 1:
                            x = _a.sent();
                            shouldContinue = predicate(x.value);
                            _a.label = 2;
                        case 2:
                            if (!((!x.done) && shouldContinue)) return [3 /*break*/, 4];
                            return [4 /*yield*/, this.next()];
                        case 3:
                            x = _a.sent();
                            shouldContinue = predicate(x.value);
                            return [3 /*break*/, 2];
                        case 4: return [2 /*return*/];
                    }
                });
            });
        };
        /**
         * Handles errors thrown on this stream using a provided handler function.
         *
         * @param handler A function that handles any `Error` thrown during a `next()`
         *   call and returns true if the stream should continue (dropping the failed
         *   call) or false if the stream should quietly terminate.  If the handler
         *   itself throws (or rethrows) an `Error`, that will be propagated.
         *
         * @returns A `LazyIterator` of elements passed through from upstream,
         *   possibly filtering or terminating on upstream `next()` calls that
         *   throw an `Error`.
         */
        LazyIterator.prototype.handleErrors = function (handler) {
            return new ErrorHandlingLazyIterator(this, handler);
        };
        // TODO(soergel): Implement reduce() etc.
        /**
         * Filters this stream according to `predicate`.
         *
         * @param predicate A function mapping a stream element to a boolean or a
         * `Promise` for one.
         *
         * @returns A `LazyIterator` of elements for which the predicate was true.
         */
        LazyIterator.prototype.filter = function (predicate) {
            return new FilterIterator(this, predicate);
        };
        /**
         * Maps this stream through a 1-to-1 transform.
         *
         * @param transform A function mapping a stream element to a transformed
         *   element.
         *
         * @returns A `LazyIterator` of transformed elements.
         */
        LazyIterator.prototype.map = function (transform) {
            return new MapIterator(this, transform);
        };
        /**
         * Maps this stream through an async 1-to-1 transform.
         *
         * @param transform A function mapping a stream element to a `Promise` for a
         *   transformed stream element.
         *
         * @returns A `LazyIterator` of transformed elements.
         */
        LazyIterator.prototype.mapAsync = function (transform) {
            return new AsyncMapIterator(this, transform);
        };
        /**
         * Maps this stream through a 1-to-1 transform, forcing serial execution.
         *
         * @param transform A function mapping a stream element to a transformed
         *   element.
         *
         * @returns A `LazyIterator` of transformed elements.
         */
        LazyIterator.prototype.serialMapAsync = function (transform) {
            return new AsyncMapIterator(this, transform).serial();
        };
        /**
         * Maps this stream through a 1-to-many transform.
         *
         * @param transform A function mapping a stream element to an array of
         *   transformed elements.
         *
         * @returns A `DataStream` of transformed elements.
         */
        LazyIterator.prototype.flatmap = function (transform) {
            return new FlatmapIterator(this, transform);
        };
        /**
         * Apply a function to every element of the stream.
         *
         * @param f A function to apply to each stream element.
         */
        LazyIterator.prototype.forEachAsync = function (f) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.map(f).resolveFully()];
                });
            });
        };
        /**
         * Apply a function to every element of the stream, forcing serial execution.
         *
         * @param f A function to apply to each stream element.  Should return 'true'
         *   to indicate that the stream should continue, or 'false' to cause it to
         *   terminate.
         */
        LazyIterator.prototype.serialForEach = function (f) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.serialMapAsync(f).resolveWhile(function (x) { return (x === true); })];
                });
            });
        };
        /**
         * Groups elements into batches, represented as arrays of elements.
         *
         * We can think of the elements of this iterator as 'rows' (even if they are
         * nested structures).  By the same token, consecutive values for a given
         * key within the elements form a 'column'.  This matches the usual sense of
         * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).
         *
         * Thus, "Row-major" means that the resulting batch is simply a collection of
         * rows: `[row1, row2, row3, ...]`.  This is contrast to the column-major
         * form, which is needed for vectorized computation.
         *
         * @param batchSize The number of elements desired per batch.
         * @param smallLastBatch Whether to emit the final batch when it has fewer
         *   than batchSize elements. Default true.
         * @returns A `LazyIterator` of batches of elements, represented as arrays
         *   of the original element type.
         */
        LazyIterator.prototype.rowMajorBatch = function (batchSize, smallLastBatch) {
            if (smallLastBatch === void 0) { smallLastBatch = true; }
            return new RowMajorBatchIterator(this, batchSize, smallLastBatch);
        };
        /**
         * Groups elements into batches, represented in column-major form.
         *
         * We can think of the elements of this iterator as 'rows' (even if they are
         * nested structures).  By the same token, consecutive values for a given
         * key within the elements form a 'column'.  This matches the usual sense of
         * 'row' and 'column' when processing tabular data (e.g., parsing a CSV).
         *
         * Thus, "column-major" means that the resulting batch is a (potentially
         * nested) structure representing the columns.  Each column entry, then,
         * contains a collection of the values found in that column for a range of
         * input elements.  This representation allows for vectorized computation, in
         * contrast to the row-major form.
         *
         * The inputs should all have the same nested structure (i.e., of arrays and
         * dicts).  The result is a single object with the same nested structure,
         * where the leaves are arrays collecting the values of the inputs at that
         * location (or, optionally, the result of a custom function applied to those
         * arrays).
         *
         * @param batchSize The number of elements desired per batch.
         * @param smallLastBatch Whether to emit the final batch when it has fewer
         *   than batchSize elements. Default true.
         * @param zipFn: (optional) A function that expects an array of elements at a
         *   single node of the object tree, and returns a `DeepMapResult`.  The
         *   `DeepMapResult` either provides a result value for that node (i.e.,
         *   representing the subtree), or indicates that the node should be processed
         *   recursively.  The default zipFn recurses as far as possible and places
         *   arrays at the leaves.
         * @returns A `LazyIterator` of batches of elements, represented as an object
         *   with collections at the leaves.
         */
        LazyIterator.prototype.columnMajorBatch = function (batchSize, smallLastBatch, 
        // tslint:disable-next-line:no-any
        zipFn) {
            if (smallLastBatch === void 0) { smallLastBatch = true; }
            if (zipFn === void 0) { zipFn = zipToList; }
            // First collect the desired number of input elements as a row-major batch.
            var rowBatches = this.rowMajorBatch(batchSize, smallLastBatch);
            // Now 'rotate' or 'pivot' the data, collecting all values from each column
            // in the batch (i.e., for each key within the elements) into an array.
            return rowBatches.map(function (x) { return deepZip(x, zipFn); });
        };
        /**
         * Concatenate this `LazyIterator` with another.
         *
         * @param iterator A `LazyIterator` to be concatenated onto this one.
         * @param baseErrorHandler An optional function that can intercept `Error`s
         *   raised during a `next()` call on the base stream.  This function can
         *   decide whether the error should be propagated, whether the error should
         *   be ignored, or whether the base stream should be terminated.
         * @returns A `LazyIterator`.
         */
        LazyIterator.prototype.concatenate = function (iterator, baseErrorHandler) {
            return new ChainedIterator(iteratorFromItems([this, iterator]), baseErrorHandler);
        };
        /**
         * Limits this stream to return at most `count` items.
         *
         * @param count The maximum number of items to provide from the stream. If
         * a negative or undefined value is given, the entire stream is returned
         *   unaltered.
         */
        LazyIterator.prototype.take = function (count) {
            if (count < 0 || count == null) {
                return this;
            }
            return new TakeIterator(this, count);
        };
        /**
         * Skips the first `count` items in this stream.
         *
         * @param count The number of items to skip.  If a negative or undefined
         * value is given, the entire stream is returned unaltered.
         */
        LazyIterator.prototype.skip = function (count) {
            if (count < 0 || count == null) {
                return this;
            }
            return new SkipIterator(this, count);
        };
        /**
         * Prefetch the first `bufferSize` items in this stream.
         *
         * Note this prefetches Promises, but makes no guarantees about when those
         * Promises resolve.
         *
         * @param bufferSize: An integer specifying the number of elements to be
         *   prefetched.
         */
        LazyIterator.prototype.prefetch = function (bufferSize) {
            return new PrefetchIterator(this, bufferSize);
        };
        // TODO(soergel): deep sharded shuffle, where supported
        /**
         * Randomly shuffles the elements of this stream.
         *
         * @param bufferSize: An integer specifying the number of elements from
         * this stream from which the new stream will sample.
         * @param seed: (Optional.) An integer specifying the random seed that
         * will be used to create the distribution.
         */
        LazyIterator.prototype.shuffle = function (windowSize, seed) {
            return new ShuffleIterator(this, windowSize, seed);
        };
        /**
         * Force an iterator to execute serially: each next() call will await the
         * prior one, so that they cannot execute concurrently.
         */
        LazyIterator.prototype.serial = function () {
            return new SerialIterator(this);
        };
        return LazyIterator;
    }());
    // ============================================================================
    // The following private classes serve to implement the chainable methods
    // on LazyIterator.  Unfortunately they can't be placed in separate files,
    // due to resulting trouble with circular imports.
    // ============================================================================
    // Iterators that just extend LazyIterator directly
    // ============================================================================
    var ArrayIterator = /** @class */ (function (_super) {
        __extends(ArrayIterator, _super);
        function ArrayIterator(items) {
            var _this = _super.call(this) || this;
            _this.items = items;
            _this.trav = 0;
            return _this;
        }
        ArrayIterator.prototype.summary = function () {
            return "Array of " + this.items.length + " items";
        };
        ArrayIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var item, result;
                return __generator(this, function (_a) {
                    if (this.trav >= this.items.length) {
                        return [2 /*return*/, { value: null, done: true }];
                    }
                    item = this.items[this.trav];
                    if (item instanceof tf.Tensor) {
                        result = tf.clone(item);
                    }
                    else {
                        result = item;
                    }
                    this.trav++;
                    return [2 /*return*/, { value: result, done: false }];
                });
            });
        };
        return ArrayIterator;
    }(LazyIterator));
    var FunctionCallIterator = /** @class */ (function (_super) {
        __extends(FunctionCallIterator, _super);
        function FunctionCallIterator(nextFn) {
            var _this = _super.call(this) || this;
            _this.nextFn = nextFn;
            return _this;
        }
        FunctionCallIterator.prototype.summary = function () {
            return "Function call";
        };
        FunctionCallIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    try {
                        return [2 /*return*/, this.nextFn()];
                    }
                    catch (e) {
                        // Modify the error message but leave the stack trace intact
                        e.message =
                            "Error thrown while iterating through a dataset: " + e.message;
                        throw e;
                    }
                    return [2 /*return*/];
                });
            });
        };
        return FunctionCallIterator;
    }(LazyIterator));
    var SerialIterator = /** @class */ (function (_super) {
        __extends(SerialIterator, _super);
        function SerialIterator(upstream) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.lastRead = Promise.resolve({ value: null, done: false });
            return _this;
        }
        SerialIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> Serial";
        };
        SerialIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    // This sets this.lastRead to a new Promise right away, as opposed to
                    // saying `await this.lastRead; this.lastRead = this.serialNext();` which
                    // would not work because this.nextRead would be updated only after the
                    // promise resolves.
                    this.lastRead = this.lastRead.then(function () { return _this.serialNext(); });
                    return [2 /*return*/, this.lastRead];
                });
            });
        };
        SerialIterator.prototype.serialNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.upstream.next()];
                });
            });
        };
        return SerialIterator;
    }(LazyIterator));
    var SkipIterator = /** @class */ (function (_super) {
        __extends(SkipIterator, _super);
        function SkipIterator(upstream, maxCount) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.maxCount = maxCount;
            // Local state that should not be clobbered by out-of-order execution.
            _this.count = 0;
            _this.lastRead = Promise.resolve({ value: null, done: false });
            return _this;
        }
        SkipIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> Skip";
        };
        SkipIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    // This sets this.lastRead to a new Promise right away, as opposed to
                    // saying `await this.lastRead; this.lastRead = this.serialNext();` which
                    // would not work because this.nextRead would be updated only after the
                    // promise resolves.
                    this.lastRead = this.lastRead.then(function () { return _this.serialNext(); });
                    return [2 /*return*/, this.lastRead];
                });
            });
        };
        SkipIterator.prototype.serialNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var skipped;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(this.count++ < this.maxCount)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.upstream.next()];
                        case 1:
                            skipped = _a.sent();
                            // short-circuit if upstream is already empty
                            if (skipped.done) {
                                return [2 /*return*/, skipped];
                            }
                            tf.dispose(skipped.value);
                            return [3 /*break*/, 0];
                        case 2: return [2 /*return*/, this.upstream.next()];
                    }
                });
            });
        };
        return SkipIterator;
    }(LazyIterator));
    var TakeIterator = /** @class */ (function (_super) {
        __extends(TakeIterator, _super);
        function TakeIterator(upstream, maxCount) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.maxCount = maxCount;
            _this.count = 0;
            return _this;
        }
        TakeIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> Take";
        };
        TakeIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (this.count++ >= this.maxCount) {
                        return [2 /*return*/, { value: null, done: true }];
                    }
                    return [2 /*return*/, this.upstream.next()];
                });
            });
        };
        return TakeIterator;
    }(LazyIterator));
    // Note this batch just groups items into row-wise element arrays.
    // Rotating these to a column-wise representation happens only at the dataset
    // level.
    var RowMajorBatchIterator = /** @class */ (function (_super) {
        __extends(RowMajorBatchIterator, _super);
        function RowMajorBatchIterator(upstream, batchSize, enableSmallLastBatch) {
            if (enableSmallLastBatch === void 0) { enableSmallLastBatch = true; }
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.batchSize = batchSize;
            _this.enableSmallLastBatch = enableSmallLastBatch;
            _this.lastRead = Promise.resolve({ value: null, done: false });
            return _this;
        }
        RowMajorBatchIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> RowMajorBatch";
        };
        RowMajorBatchIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    // This sets this.lastRead to a new Promise right away, as opposed to
                    // saying `await this.lastRead; this.lastRead = this.serialNext();` which
                    // would not work because this.nextRead would be updated only after the
                    // promise resolves.
                    this.lastRead = this.lastRead.then(function () { return _this.serialNext(); });
                    return [2 /*return*/, this.lastRead];
                });
            });
        };
        RowMajorBatchIterator.prototype.serialNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var batch, item;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            batch = [];
                            _a.label = 1;
                        case 1:
                            if (!(batch.length < this.batchSize)) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.upstream.next()];
                        case 2:
                            item = _a.sent();
                            if (item.done) {
                                if (this.enableSmallLastBatch && batch.length > 0) {
                                    return [2 /*return*/, { value: batch, done: false }];
                                }
                                return [2 /*return*/, { value: null, done: true }];
                            }
                            batch.push(item.value);
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/, { value: batch, done: false }];
                    }
                });
            });
        };
        return RowMajorBatchIterator;
    }(LazyIterator));
    var FilterIterator = /** @class */ (function (_super) {
        __extends(FilterIterator, _super);
        function FilterIterator(upstream, predicate) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.predicate = predicate;
            _this.lastRead = Promise.resolve({ value: null, done: false });
            return _this;
        }
        FilterIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> Filter";
        };
        FilterIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    // This sets this.lastRead to a new Promise right away, as opposed to
                    // saying `await this.lastRead; this.lastRead = this.serialNext();` which
                    // would not work because this.nextRead would be updated only after the
                    // promise resolves.
                    this.lastRead = this.lastRead.then(function () { return _this.serialNext(); });
                    return [2 /*return*/, this.lastRead];
                });
            });
        };
        FilterIterator.prototype.serialNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var item;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            return [4 /*yield*/, this.upstream.next()];
                        case 1:
                            item = _a.sent();
                            if (item.done || this.predicate(item.value)) {
                                return [2 /*return*/, item];
                            }
                            tf.dispose(item.value);
                            return [3 /*break*/, 0];
                        case 2: return [2 /*return*/];
                    }
                });
            });
        };
        return FilterIterator;
    }(LazyIterator));
    var MapIterator = /** @class */ (function (_super) {
        __extends(MapIterator, _super);
        function MapIterator(upstream, transform) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.transform = transform;
            return _this;
        }
        MapIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> Map";
        };
        MapIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var item, inputTensors, mapped, outputTensors, _i, inputTensors_1, t;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.upstream.next()];
                        case 1:
                            item = _a.sent();
                            if (item.done) {
                                return [2 /*return*/, { value: null, done: true }];
                            }
                            inputTensors = tensor_util_6(item.value);
                            mapped = this.transform(item.value);
                            outputTensors = tensor_util_6(mapped);
                            // TODO(soergel) faster intersection
                            // TODO(soergel) move to tf.disposeExcept(in, out)?
                            for (_i = 0, inputTensors_1 = inputTensors; _i < inputTensors_1.length; _i++) {
                                t = inputTensors_1[_i];
                                if (!tensor_util_3(t, outputTensors)) {
                                    t.dispose();
                                }
                            }
                            return [2 /*return*/, { value: mapped, done: false }];
                    }
                });
            });
        };
        return MapIterator;
    }(LazyIterator));
    var ErrorHandlingLazyIterator = /** @class */ (function (_super) {
        __extends(ErrorHandlingLazyIterator, _super);
        function ErrorHandlingLazyIterator(upstream, handler) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.handler = handler;
            _this.count = 0;
            _this.lastRead = Promise.resolve({ value: null, done: false });
            return _this;
        }
        ErrorHandlingLazyIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> handleErrors";
        };
        ErrorHandlingLazyIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    // This sets this.lastRead to a new Promise right away, as opposed to
                    // saying `await this.lastRead; this.lastRead = this.serialNext();` which
                    // would not work because this.nextRead would be updated only after the
                    // promise resolves.
                    this.lastRead = this.lastRead.then(function () { return _this.serialNext(); });
                    return [2 /*return*/, this.lastRead];
                });
            });
        };
        ErrorHandlingLazyIterator.prototype.serialNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var e_1;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            _a.label = 1;
                        case 1:
                            _a.trys.push([1, 3, , 4]);
                            return [4 /*yield*/, this.upstream.next()];
                        case 2: return [2 /*return*/, _a.sent()];
                        case 3:
                            e_1 = _a.sent();
                            if (!this.handler(e_1)) {
                                return [2 /*return*/, { value: null, done: true }];
                            }
                            return [3 /*break*/, 4];
                        case 4: return [3 /*break*/, 0];
                        case 5: return [2 /*return*/];
                    }
                });
            });
        };
        return ErrorHandlingLazyIterator;
    }(LazyIterator));
    var AsyncMapIterator = /** @class */ (function (_super) {
        __extends(AsyncMapIterator, _super);
        function AsyncMapIterator(upstream, transform) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.transform = transform;
            return _this;
        }
        AsyncMapIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> AsyncMap";
        };
        AsyncMapIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var item, inputTensors, mapped, outputTensors, _i, inputTensors_2, t;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.upstream.next()];
                        case 1:
                            item = _a.sent();
                            if (item.done) {
                                return [2 /*return*/, { value: null, done: true }];
                            }
                            inputTensors = tensor_util_6(item.value);
                            return [4 /*yield*/, this.transform(item.value)];
                        case 2:
                            mapped = _a.sent();
                            outputTensors = tensor_util_6(mapped);
                            // TODO(soergel) faster intersection
                            // TODO(soergel) move to tf.disposeExcept(in, out)?
                            for (_i = 0, inputTensors_2 = inputTensors; _i < inputTensors_2.length; _i++) {
                                t = inputTensors_2[_i];
                                if (!tensor_util_3(t, outputTensors)) {
                                    t.dispose();
                                }
                            }
                            return [2 /*return*/, { value: mapped, done: false }];
                    }
                });
            });
        };
        return AsyncMapIterator;
    }(LazyIterator));
    // Iterators that maintain a queue of pending items
    // ============================================================================
    /**
     * A base class for transforming streams that operate by maintaining an
     * output queue of elements that are ready to return via next().  This is
     * commonly required when the transformation is 1-to-many:  A call to next()
     * may trigger a call to the underlying stream, which will produce many
     * mapped elements of this stream-- of which we need to return only one, so
     * we have to queue the rest.
     */
    var OneToManyIterator = /** @class */ (function (_super) {
        __extends(OneToManyIterator, _super);
        function OneToManyIterator() {
            var _this = _super.call(this) || this;
            _this.outputQueue = new GrowingRingBuffer();
            _this.lastRead = Promise.resolve({ value: null, done: false });
            return _this;
        }
        OneToManyIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    // This sets this.lastRead to a new Promise right away, as opposed to
                    // saying `await this.lastRead; this.lastRead = this.serialNext();` which
                    // would not work because this.nextRead would be updated only after the
                    // promise resolves.
                    this.lastRead = this.lastRead.then(function () { return _this.serialNext(); });
                    return [2 /*return*/, this.lastRead];
                });
            });
        };
        OneToManyIterator.prototype.serialNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!(this.outputQueue.length() === 0)) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.pump()];
                        case 1:
                            // TODO(soergel): consider parallel reads.
                            if (!(_a.sent())) {
                                return [2 /*return*/, { value: null, done: true }];
                            }
                            return [3 /*break*/, 0];
                        case 2: return [2 /*return*/, { value: this.outputQueue.shift(), done: false }];
                    }
                });
            });
        };
        return OneToManyIterator;
    }(LazyIterator));
    var FlatmapIterator = /** @class */ (function (_super) {
        __extends(FlatmapIterator, _super);
        function FlatmapIterator(upstream, transform) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.transform = transform;
            return _this;
        }
        FlatmapIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> Flatmap";
        };
        FlatmapIterator.prototype.pump = function () {
            return __awaiter(this, void 0, void 0, function () {
                var item, inputTensors, mappedArray, outputTensors, _i, inputTensors_3, t;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.upstream.next()];
                        case 1:
                            item = _a.sent();
                            if (item.done) {
                                return [2 /*return*/, false];
                            }
                            inputTensors = tensor_util_6(item.value);
                            mappedArray = this.transform(item.value);
                            outputTensors = tensor_util_6(mappedArray);
                            this.outputQueue.pushAll(mappedArray);
                            // TODO(soergel) faster intersection, and deduplicate outputTensors
                            // TODO(soergel) move to tf.disposeExcept(in, out)?
                            for (_i = 0, inputTensors_3 = inputTensors; _i < inputTensors_3.length; _i++) {
                                t = inputTensors_3[_i];
                                if (!tensor_util_3(t, outputTensors)) {
                                    t.dispose();
                                }
                            }
                            return [2 /*return*/, true];
                    }
                });
            });
        };
        return FlatmapIterator;
    }(OneToManyIterator));
    /**
     * Provides a `LazyIterator` that concatenates a stream of underlying
     * streams.
     *
     * Doing this in a concurrency-safe way requires some trickery.  In
     * particular, we want this stream to return the elements from the
     * underlying streams in the correct order according to when next() was
     * called, even if the resulting Promises resolve in a different order.
     */
    var ChainedIterator = /** @class */ (function (_super) {
        __extends(ChainedIterator, _super);
        function ChainedIterator(iterators, baseErrorHandler) {
            var _this = _super.call(this) || this;
            _this.baseErrorHandler = baseErrorHandler;
            // Strict Promise execution order:
            // a next() call may not even begin until the previous one completes.
            _this.lastRead = null;
            // Local state that should not be clobbered by out-of-order execution.
            _this.iterator = null;
            _this.moreIterators = iterators;
            return _this;
        }
        ChainedIterator.prototype.summary = function () {
            var upstreamSummaries = 'TODO: fill in upstream of chained summaries';
            return upstreamSummaries + " -> Chained";
        };
        ChainedIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    this.lastRead = this.readFromChain(this.lastRead);
                    return [2 /*return*/, this.lastRead];
                });
            });
        };
        ChainedIterator.prototype.readFromChain = function (lastRead) {
            return __awaiter(this, void 0, void 0, function () {
                var iteratorResult, itemResult;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: 
                        // Must await on the previous read since the previous read may have advanced
                        // the stream of streams, from which we need to read.
                        // This is unfortunate since we can't parallelize reads. Which means
                        // prefetching of chained streams is a no-op.
                        // One solution is to prefetch immediately upstream of this.
                        return [4 /*yield*/, lastRead];
                        case 1:
                            // Must await on the previous read since the previous read may have advanced
                            // the stream of streams, from which we need to read.
                            // This is unfortunate since we can't parallelize reads. Which means
                            // prefetching of chained streams is a no-op.
                            // One solution is to prefetch immediately upstream of this.
                            _a.sent();
                            if (!(this.iterator == null)) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.moreIterators.next()];
                        case 2:
                            iteratorResult = _a.sent();
                            if (iteratorResult.done) {
                                // No more streams to stream from.
                                return [2 /*return*/, { value: null, done: true }];
                            }
                            this.iterator = iteratorResult.value;
                            if (this.baseErrorHandler != null) {
                                this.iterator = this.iterator.handleErrors(this.baseErrorHandler);
                            }
                            _a.label = 3;
                        case 3: return [4 /*yield*/, this.iterator.next()];
                        case 4:
                            itemResult = _a.sent();
                            if (itemResult.done) {
                                this.iterator = null;
                                return [2 /*return*/, this.readFromChain(lastRead)];
                            }
                            return [2 /*return*/, itemResult];
                    }
                });
            });
        };
        return ChainedIterator;
    }(LazyIterator));
    var ZipMismatchMode;
    (function (ZipMismatchMode) {
        ZipMismatchMode[ZipMismatchMode["FAIL"] = 0] = "FAIL";
        ZipMismatchMode[ZipMismatchMode["SHORTEST"] = 1] = "SHORTEST";
        ZipMismatchMode[ZipMismatchMode["LONGEST"] = 2] = "LONGEST"; // use nulls for exhausted streams; use up the longest stream.
    })(ZipMismatchMode || (ZipMismatchMode = {}));
    /**
     * Provides a `LazyIterator` that zips together an array, dict, or nested
     * structure of `LazyIterator`s (and perhaps additional constants).
     *
     * The underlying streams must provide elements in a consistent order such
     * that they correspond.
     *
     * Typically, the underlying streams should have the same number of
     * elements. If they do not, the behavior is determined by the
     * `mismatchMode` argument.
     *
     * The nested structure of the `iterators` argument determines the
     * structure of elements in the resulting iterator.
     *
     * Doing this in a concurrency-safe way requires some trickery.  In
     * particular, we want this stream to return the elements from the
     * underlying streams in the correct order according to when next() was
     * called, even if the resulting Promises resolve in a different order.
     *
     * @param iterators: An array or object containing LazyIterators at the
     * leaves.
     * @param mismatchMode: Determines what to do when one underlying iterator
     * is exhausted before the others.  `ZipMismatchMode.FAIL` (the default)
     * causes an error to be thrown in this case.  `ZipMismatchMode.SHORTEST`
     * causes the zipped iterator to terminate with the furst underlying
     * streams, so elements remaining on the longer streams are ignored.
     * `ZipMismatchMode.LONGEST` causes the zipped stream to continue, filling
     * in nulls for the exhausted streams, until all streams are exhausted.
     */
    var ZipIterator = /** @class */ (function (_super) {
        __extends(ZipIterator, _super);
        function ZipIterator(iterators, mismatchMode) {
            if (mismatchMode === void 0) { mismatchMode = ZipMismatchMode.FAIL; }
            var _this = _super.call(this) || this;
            _this.iterators = iterators;
            _this.mismatchMode = mismatchMode;
            _this.count = 0;
            _this.currentPromise = null;
            return _this;
        }
        ZipIterator.prototype.summary = function () {
            var upstreamSummaries = 'TODO: fill in upstream of zip summaries';
            return "{" + upstreamSummaries + "} -> Zip";
        };
        ZipIterator.prototype.nextState = function (afterState) {
            return __awaiter(this, void 0, void 0, function () {
                function getNext(container) {
                    if (container instanceof LazyIterator) {
                        var result = container.next();
                        return {
                            value: result.then(function (x) {
                                numIterators++;
                                if (x.done) {
                                    iteratorsDone++;
                                }
                                return x.value;
                            }),
                            recurse: false
                        };
                    }
                    else {
                        return { value: null, recurse: true };
                    }
                }
                var numIterators, iteratorsDone, mapped;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: 
                        // This chaining ensures that the underlying next() are not even called
                        // before the previous ones have resolved.
                        return [4 /*yield*/, afterState];
                        case 1:
                            // This chaining ensures that the underlying next() are not even called
                            // before the previous ones have resolved.
                            _a.sent();
                            numIterators = 0;
                            iteratorsDone = 0;
                            return [4 /*yield*/, deepMapAndAwaitAll(this.iterators, getNext)];
                        case 2:
                            mapped = _a.sent();
                            if (numIterators === iteratorsDone) {
                                // The streams have all ended.
                                return [2 /*return*/, { value: null, done: true }];
                            }
                            if (iteratorsDone > 0) {
                                switch (this.mismatchMode) {
                                    case ZipMismatchMode.FAIL:
                                        throw new Error('Zipped streams should have the same length. ' +
                                            ("Mismatched at element " + this.count + "."));
                                    case ZipMismatchMode.SHORTEST:
                                        return [2 /*return*/, { value: null, done: true }];
                                    case ZipMismatchMode.LONGEST:
                                    default:
                                    // Continue.  The exhausted streams already produced value: null.
                                }
                            }
                            this.count++;
                            return [2 /*return*/, { value: mapped, done: false }];
                    }
                });
            });
        };
        ZipIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            this.currentPromise = this.nextState(this.currentPromise);
                            return [4 /*yield*/, this.currentPromise];
                        case 1: return [2 /*return*/, (_a.sent())];
                    }
                });
            });
        };
        return ZipIterator;
    }(LazyIterator));
    // Iterators that maintain a ring buffer of pending promises
    // ============================================================================
    /**
     * A stream that prefetches a given number of items from an upstream source,
     * returning them in FIFO order.
     *
     * Note this prefetches Promises, but makes no guarantees about when those
     * Promises resolve.
     */
    var PrefetchIterator = /** @class */ (function (_super) {
        __extends(PrefetchIterator, _super);
        function PrefetchIterator(upstream, bufferSize) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.bufferSize = bufferSize;
            _this.buffer = new RingBuffer(bufferSize);
            return _this;
        }
        PrefetchIterator.prototype.summary = function () {
            return this.upstream.summary() + " -> Prefetch";
        };
        /**
         * Refill the prefetch buffer.  Returns only after the buffer is full, or
         * the upstream source is exhausted.
         */
        PrefetchIterator.prototype.refill = function () {
            while (!this.buffer.isFull()) {
                var v = this.upstream.next();
                this.buffer.push(v);
            }
        };
        PrefetchIterator.prototype.next = function () {
            this.refill();
            // This shift will never throw an error because the buffer is always
            // full after a refill. If the stream is exhausted, the buffer will be
            // full of Promises that will resolve to the end-of-stream signal.
            return this.buffer.shift();
        };
        return PrefetchIterator;
    }(LazyIterator));
    /**
     * A stream that performs a sliding-window random shuffle on an upstream
     * source. This is like a `PrefetchIterator` except that the items are
     * returned in randomized order.  Mixing naturally improves as the buffer
     * size increases.
     */
    var ShuffleIterator = /** @class */ (function (_super) {
        __extends(ShuffleIterator, _super);
        function ShuffleIterator(upstream, windowSize, seed) {
            var _this = _super.call(this, upstream, windowSize) || this;
            _this.upstream = upstream;
            _this.windowSize = windowSize;
            // Local state that should not be clobbered by out-of-order execution.
            _this.upstreamExhausted = false;
            _this.random = seedrandom_1(seed || tf.util.now().toString());
            _this.lastRead = Promise.resolve({ value: null, done: false });
            return _this;
        }
        ShuffleIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var _this = this;
                return __generator(this, function (_a) {
                    // This sets this.lastRead to a new Promise right away, as opposed to
                    // saying `await this.lastRead; this.lastRead = this.serialNext();` which
                    // would not work because this.nextRead would be updated only after the
                    // promise resolves.
                    this.lastRead = this.lastRead.then(function () { return _this.serialNext(); });
                    return [2 /*return*/, this.lastRead];
                });
            });
        };
        ShuffleIterator.prototype.randomInt = function (max) {
            return Math.floor(this.random() * max);
        };
        ShuffleIterator.prototype.chooseIndex = function () {
            return this.randomInt(this.buffer.length());
        };
        ShuffleIterator.prototype.serialNext = function () {
            return __awaiter(this, void 0, void 0, function () {
                var chosenIndex, result;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            // TODO(soergel): consider performance
                            if (!this.upstreamExhausted) {
                                this.refill();
                            }
                            _a.label = 1;
                        case 1:
                            if (!!this.buffer.isEmpty()) return [3 /*break*/, 3];
                            chosenIndex = this.chooseIndex();
                            return [4 /*yield*/, this.buffer.shuffleExcise(chosenIndex)];
                        case 2:
                            result = _a.sent();
                            if (result.done) {
                                this.upstreamExhausted = true;
                            }
                            else {
                                this.refill();
                                return [2 /*return*/, result];
                            }
                            return [3 /*break*/, 1];
                        case 3: return [2 /*return*/, { value: null, done: true }];
                    }
                });
            });
        };
        return ShuffleIterator;
    }(PrefetchIterator));

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    // TODO(soergel): consider vectorized operations within the pipeline.
    /**
     * Represents a potentially large list of independent data elements (typically
     * 'samples' or 'examples').
     *
     * A 'data example' may be a primitive, an array, a map from string keys to
     * values, or any nested structure of these.
     *
     * A `Dataset` represents an ordered collection of elements, together with a
     * chain of transformations to be performed on those elements. Each
     * transformation is a method of `Dataset` that returns another `Dataset`, so
     * these may be chained, e.g.
     * `const processedDataset = rawDataset.filter(...).map(...).batch(...)`.
     *
     * Data loading and transformation is done in a lazy, streaming fashion.  The
     * dataset may be iterated over multiple times; each iteration starts the data
     * loading anew and recapitulates the transformations.
     *
     * A `Dataset` is typically processed as a stream of unbatched examples --i.e.,
     * its transformations are applied one example at a time. Batching produces a
     * new `Dataset` where each element is a batch. Batching should usually come
     * last in a pipeline, because data transformations are easier to express on a
     * per-example basis than on a per-batch basis.
     *
     * The following code examples are calling `await dataset.forEachAsync(...)` to
     * iterate once over the entire dataset in order to print out the data.
     */
    /** @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'} */
    var Dataset = /** @class */ (function () {
        function Dataset() {
            this.size = null;
        }
        // TODO(soergel): Make Datasets report whether repeated iterator() calls
        // produce the same result (e.g., reading from a file) or different results
        // (e.g., from the webcam).  Currently we don't make this distinction but it
        // could be important for the user to know.
        // abstract isDeterministic(): boolean;
        /**
         * Groups elements into batches.
         *
         * It is assumed that each of the incoming dataset elements has the same
         * structure-- i.e. the same set of keys at each location in an object
         * hierarchy.  For each key, the resulting `Dataset` provides a batched
         * element collecting all of the incoming values for that key.
         *
         *  * Incoming primitives are grouped into a 1-D Tensor.
         *  * Incoming Tensors are grouped into a new Tensor where the 0'th axis is
         *    the batch dimension.
         *  * Incoming arrays are converted to Tensor and then batched.
         *  * A nested array is interpreted as an n-D Tensor, so the batched result
         *    has n+1 dimensions.
         *  * An array that cannot be converted to Tensor produces an error.
         *
         * If an array should not be batched as a unit, it should first be converted
         * to an object with integer keys.
         *
         * Here are a few examples:
         *
         * Batch a dataset of numbers:
         * ```js
         * const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8]).batch(4);
         * await a.forEachAsync(e => e.print());
         * ```
         *
         * Batch a dataset of arrays:
         * ```js
         * const b = tf.data.array([[1], [2], [3], [4], [5], [6], [7], [8]]).batch(4);
         * await b.forEachAsync(e => e.print());
         * ```
         *
         * Batch a dataset of objects:
         * ```js
         * const c = tf.data.array([{a: 1, b: 11}, {a: 2, b: 12}, {a: 3, b: 13},
         *   {a: 4, b: 14}, {a: 5, b: 15}, {a: 6, b: 16}, {a: 7, b: 17},
         *   {a: 8, b: 18}]).batch(4);
         * await c.forEachAsync(e => {
         *   console.log('{');
         *   for(var key in e) {
         *     console.log(key+':');
         *     e[key].print();
         *   }
         *   console.log('}');
         * })
         * ```
         *
         * @param batchSize The number of elements desired per batch.
         * @param smallLastBatch Whether to emit the final batch when it has fewer
         *   than batchSize elements. Default true.
         * @returns A `Dataset`, from which a stream of batches can be obtained.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.batch = function (batchSize, smallLastBatch) {
            var _this = this;
            if (smallLastBatch === void 0) { smallLastBatch = true; }
            var base = this;
            tf.util.assert(batchSize > 0, function () { return "batchSize needs to be positive, but it is\n      " + batchSize; });
            var size;
            if (this.size === Infinity || this.size == null) {
                // If the size of this dataset is infinity or null, the new size keeps the
                // same.
                size = this.size;
            }
            else if (smallLastBatch) {
                // If the size of this dataset is known and include small last batch, the
                // new size is full batch count plus last batch.
                size = Math.ceil(this.size / batchSize);
            }
            else {
                // If the size of this dataset is known and not include small last batch,
                // the new size is full batch count.
                size = Math.floor(this.size / batchSize);
            }
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, base.iterator()];
                        case 1: return [2 /*return*/, (_a.sent())
                                .columnMajorBatch(batchSize, smallLastBatch, deepBatchConcat)];
                    }
                });
            }); }, size);
        };
        /**
         * Concatenates this `Dataset` with another.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3]);
         * const b = tf.data.array([4, 5, 6]);
         * const c = a.concatenate(b);
         * await c.forEachAsync(e => console.log(e));
         * ```
         *
         * @param dataset A `Dataset` to be concatenated onto this one.
         * @returns A `Dataset`.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.concatenate = function (dataset) {
            var _this = this;
            var base = this;
            var size;
            if (this.size === Infinity || dataset.size === Infinity) {
                // If the size of any of these two dataset is infinity, new size is
                // infinity.
                size = Infinity;
            }
            else if (this.size != null && dataset.size != null) {
                // If the size of both datasets are known and not infinity, new size is
                // sum the size of these two datasets.
                size = this.size + dataset.size;
            }
            else {
                // If neither of these two datasets has infinite size and any of these two
                // datasets' size is null, the new size is null.
                size = null;
            }
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () { var _a, _b; return __generator(this, function (_c) {
                switch (_c.label) {
                    case 0: return [4 /*yield*/, base.iterator()];
                    case 1:
                        _b = (_a = (_c.sent())).concatenate;
                        return [4 /*yield*/, dataset.iterator()];
                    case 2: return [2 /*return*/, _b.apply(_a, [_c.sent()])];
                }
            }); }); }, size);
        };
        /**
         * Filters this dataset according to `predicate`.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])
         *   .filter(x => x%2 === 0);
         * await a.forEachAsync(e => console.log(e));
         * ```
         *
         * @param predicate A function mapping a dataset element to a boolean or a
         * `Promise` for one.
         *
         * @returns A `Dataset` of elements for which the predicate was true.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.filter = function (predicate) {
            var _this = this;
            var base = this;
            var size;
            if (this.size === Infinity) {
                // If the size of this dataset is infinity, new size is infinity
                size = Infinity;
            }
            else {
                // If this dataset has limited elements, new size is null because it might
                // exhausted randomly.
                size = null;
            }
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, base.iterator()];
                        case 1: return [2 /*return*/, (_a.sent()).filter(function (x) { return tf.tidy(function () { return predicate(x); }); })];
                    }
                });
            }); }, size);
        };
        /**
         * Apply a function to every element of the dataset.
         *
         * After the function is applied to a dataset element, any Tensors contained
         * within that element are disposed.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3]);
         * await a.forEachAsync(e => console.log(e));
         * ```
         *
         * @param f A function to apply to each dataset element.
         * @returns A `Promise` that resolves after all elements have been processed.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.forEachAsync = function (f) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.iterator()];
                        case 1: return [2 /*return*/, (_a.sent()).forEachAsync(f)];
                    }
                });
            });
        };
        /** @deprecated Please use `dataset.forEachAsync()` instead. */
        Dataset.prototype.forEach = function (f) {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    tf.deprecationWarn('dataset.forEach() is deprecated and will be removed. ' +
                        'Please use dataset.forEachAsync() instead');
                    return [2 /*return*/, this.forEachAsync(f)];
                });
            });
        };
        /**
         * Maps this dataset through a 1-to-1 transform.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3]).map(x => x*x);
         * await a.forEachAsync(e => console.log(e));
         * ```
         *
         * @param transform A function mapping a dataset element to a transformed
         *   dataset element.
         *
         * @returns A `Dataset` of transformed elements.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.map = function (transform) {
            var _this = this;
            var base = this;
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, base.iterator()];
                        case 1: return [2 /*return*/, (_a.sent()).map(function (x) { return tf.tidy(function () { return transform(x); }); })];
                    }
                });
            }); }, this.size);
        };
        /**
         * Maps this dataset through an async 1-to-1 transform.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3]).map(x => new Promise(function(resolve){
         *  resolve(x*x);
         * }));
         * await a.forEachAsync(e => e.then(function(value){
         *  console.log(value);
         * }));
         * ```
         *
         * @param transform A function mapping a dataset element to a `Promise` for a
         *   transformed dataset element.  This transform is responsible for disposing
         *   any intermediate `Tensor`s, i.e. by wrapping its computation in
         *   `tf.tidy()`; that cannot be automated here (as it is in the synchronous
         *   `map()` case).
         *
         * @returns A `Dataset` of transformed elements.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.mapAsync = function (transform) {
            var _this = this;
            var base = this;
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, base.iterator()];
                        case 1: return [2 /*return*/, (_a.sent()).mapAsync(transform)];
                    }
                });
            }); }, this.size);
        };
        /**
         *  Creates a `Dataset` that prefetches elements from this dataset.
         *
         * @param bufferSize: An integer specifying the number of elements to be
         *   prefetched.
         * @returns A `Dataset`.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.prefetch = function (bufferSize) {
            var _this = this;
            if (bufferSize == null) {
                throw new RangeError('`Dataset.prefetch()` requires bufferSize to be specified.');
            }
            var base = this;
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, base.iterator()];
                    case 1: return [2 /*return*/, (_a.sent()).prefetch(bufferSize)];
                }
            }); }); }, this.size);
        };
        /**
         * Repeats this dataset `count` times.
         *
         * NOTE: If this dataset is a function of global state (e.g. a random number
         * generator), then different repetitions may produce different elements.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3]).repeat(3);
         * await a.forEachAsync(e => console.log(e));
         * ```
         *
         * @param count: (Optional) An integer, representing the number of times
         *   the dataset should be repeated. The default behavior (if `count` is
         *   `undefined` or negative) is for the dataset be repeated indefinitely.
         * @returns A `Dataset`.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.repeat = function (count) {
            var _this = this;
            var base = this;
            var size;
            if (this.size != null && count > 0) {
                // If this dataset has size and count is positive, new size is current
                // size multiply count. This also covers the case that current size is
                // infinity.
                size = this.size * count;
            }
            else if (count === 0) {
                // If count is 0, new size is 0.
                size = 0;
            }
            else if (this.size != null && (count === undefined || count < 0)) {
                // If this dataset has size and count is undefined or negative, the
                // dataset will be repeated indefinitely and new size is infinity.
                size = Infinity;
            }
            else {
                // If the size of this dataset is null, the new dataset's size is null.
                size = null;
            }
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () {
                var iteratorIterator;
                var _this = this;
                return __generator(this, function (_a) {
                    iteratorIterator = iteratorFromFunction(function () { return __awaiter(_this, void 0, void 0, function () { var _a; return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0:
                                _a = {};
                                return [4 /*yield*/, base.iterator()];
                            case 1: return [2 /*return*/, (_a.value = _b.sent(), _a.done = false, _a)];
                        }
                    }); }); });
                    return [2 /*return*/, iteratorFromConcatenated(iteratorIterator.take(count))];
                });
            }); }, size);
        };
        /**
         * Creates a `Dataset` that skips `count` initial elements from this dataset.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3, 4, 5, 6]).skip(3);
         * await a.forEachAsync(e => console.log(e));
         * ```
         *
         * @param count: The number of elements of this dataset that should be skipped
         *   to form the new dataset.  If `count` is greater than the size of this
         *   dataset, the new dataset will contain no elements.  If `count`
         *   is `undefined` or negative, skips the entire dataset.
         *
         * @returns A `Dataset`.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.skip = function (count) {
            var _this = this;
            var base = this;
            var size;
            if (this.size != null && count >= 0 && this.size >= count) {
                // If the size of this dataset is greater than count, the new dataset's
                // size is current size minus skipped size.This also covers the case that
                // current size is infinity.
                size = this.size - count;
            }
            else if (this.size != null &&
                (this.size < count || count === undefined || count < 0)) {
                // If the size of this dataset is smaller than count, or count is
                // undefined or negative, skips the entire dataset and the new size is 0.
                size = 0;
            }
            else {
                // If the size of this dataset is null, the new dataset's size is null.
                size = null;
            }
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, base.iterator()];
                    case 1: return [2 /*return*/, (_a.sent()).skip(count)];
                }
            }); }); }, size);
        };
        /**
         * Pseudorandomly shuffles the elements of this dataset. This is done in a
         * streaming manner, by sampling from a given number of prefetched elements.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3, 4, 5, 6]).shuffle(3);
         * await a.forEachAsync(e => console.log(e));
         * ```
         *
         * @param bufferSize: An integer specifying the number of elements from this
         *   dataset from which the new dataset will sample.
         * @param seed: (Optional) An integer specifying the random seed that will
         *   be used to create the distribution.
         * @param reshuffleEachIteration: (Optional) A boolean, which if true
         *   indicates that the dataset should be pseudorandomly reshuffled each time
         *   it is iterated over. If false, elements will be returned in the same
         *   shuffled order on each iteration. (Defaults to `true`.)
         * @returns A `Dataset`.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.shuffle = function (bufferSize, seed, reshuffleEachIteration) {
            var _this = this;
            if (reshuffleEachIteration === void 0) { reshuffleEachIteration = true; }
            if (bufferSize == null || bufferSize < 0) {
                if (this.size == null) {
                    throw new RangeError('`Dataset.shuffle()` requires bufferSize to be specified.');
                }
                else {
                    throw new RangeError('`Dataset.shuffle()` requires bufferSize to be specified.  ' +
                        'If your data fits in main memory (for regular JS objects), ' +
                        'and/or GPU memory (for `tf.Tensor`s), consider setting ' +
                        ("bufferSize to the dataset size (" + this.size + " elements)"));
                }
            }
            var base = this;
            var random = seedrandom_1(seed || tf.util.now().toString());
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () {
                var seed2;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            seed2 = random.int32();
                            if (reshuffleEachIteration) {
                                seed2 += random.int32();
                            }
                            return [4 /*yield*/, base.iterator()];
                        case 1: return [2 /*return*/, (_a.sent()).shuffle(bufferSize, seed2.toString())];
                    }
                });
            }); }, this.size);
        };
        /**
         * Creates a `Dataset` with at most `count` initial elements from this
         * dataset.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3, 4, 5, 6]).take(3);
         * await a.forEachAsync(e => console.log(e));
         * ```
         *
         * @param count: The number of elements of this dataset that should be taken
         *   to form the new dataset.  If `count` is `undefined` or negative, or if
         *   `count` is greater than the size of this dataset, the new dataset will
         *   contain all elements of this dataset.
         * @returns A `Dataset`.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.take = function (count) {
            var _this = this;
            var base = this;
            var size;
            if (this.size != null && this.size > count) {
                // If the size of this dataset is greater than count, the new dataset's
                // size is count.
                size = count;
            }
            else if (this.size != null && this.size <= count) {
                // If the size of this dataset is equal or smaller than count, the new
                // dataset's size is the size of this dataset.
                size = this.size;
            }
            else {
                // If the size of this dataset is null, the new dataset's size is null.
                size = null;
            }
            return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, base.iterator()];
                    case 1: return [2 /*return*/, (_a.sent()).take(count)];
                }
            }); }); }, size);
        };
        /**
         * Collect all elements of this dataset into an array.
         *
         * Obviously this will succeed only for small datasets that fit in memory.
         * Useful for testing and generally should be avoided if possible.
         *
         * ```js
         * const a = tf.data.array([1, 2, 3, 4, 5, 6]);
         * console.log(await a.toArray());
         * ```
         *
         * @returns A Promise for an array of elements, which will resolve
         *   when a new stream has been obtained and fully consumed.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        Dataset.prototype.toArray = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.size === Infinity) {
                                throw new Error('Can not convert infinite data stream to array.');
                            }
                            return [4 /*yield*/, this.iterator()];
                        case 1: return [2 /*return*/, (_a.sent()).toArray()];
                    }
                });
            });
        };
        /**
         * Collect all elements of this dataset into an array with prefetching 100
         * elements. This is useful for testing, because the prefetch changes the
         * order in which the Promises are resolved along the processing pipeline.
         * This may help expose bugs where results are dependent on the order of
         * Promise resolution rather than on the logical order of the stream (i.e.,
         * due to hidden mutable state).
         *
         * @returns A Promise for an array of elements, which will resolve
         *   when a new stream has been obtained and fully consumed.
         */
        Dataset.prototype.toArrayForTest = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (this.size === Infinity) {
                                throw new Error('Can not convert infinite data stream to array.');
                            }
                            return [4 /*yield*/, this.iterator()];
                        case 1: return [2 /*return*/, (_a.sent()).toArrayForTest()];
                    }
                });
            });
        };
        // TODO(soergel): deep sharded shuffle, where supported
        Dataset.MAX_BUFFER_SIZE = 10000;
        return Dataset;
    }());
    /**
     * Create a `Dataset` defined by a provided iterator() function.
     *
     * ```js
     * let i = -1;
     * const func = () =>
     *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};
     * const iter = tf.data.iteratorFromFunction(func);
     * const ds = tf.data.datasetFromIteratorFn(iter);
     * await ds.forEachAsync(e => console.log(e));
     * ```
     */
    function datasetFromIteratorFn(iteratorFn, size) {
        if (size === void 0) { size = null; }
        return new /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.size = size;
                return _this;
            }
            /*
             * Provide a new stream of elements.  Note this will also start new streams
             * from any underlying `Dataset`s.
             */
            class_1.prototype.iterator = function () {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        return [2 /*return*/, iteratorFn()];
                    });
                });
            };
            return class_1;
        }(Dataset))();
    }
    /**
     * Create a `Dataset` from an array of elements.
     *
     * Create a Dataset from an array of objects:
     * ```js
     * const a = tf.data.array([{'item': 1}, {'item': 2}, {'item': 3}]);
     * await a.forEachAsync(e => console.log(e));
     * ```
     *
     * Create a Dataset from an array of numbers:
     * ```js
     * const a = tf.data.array([4, 5, 6]);
     * await a.forEachAsync(e => console.log(e));
     * ```
     * @param items An array of elements that will be parsed as items in a dataset.
     */
    /** @doc {heading: 'Data', subheading: 'Creation', namespace: 'data'} */
    function array(items) {
        var _this = this;
        return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/, iteratorFromItems(items)];
        }); }); }, items.length);
    }
    /**
     * Create a `Dataset` by zipping together an array, dict, or nested
     * structure of `Dataset`s (and perhaps additional constants).
     * The underlying datasets must provide elements in a consistent order such that
     * they correspond.
     *
     * The number of elements in the resulting dataset is the same as the size of
     * the smallest dataset in datasets.
     *
     * The nested structure of the `datasets` argument determines the
     * structure of elements in the resulting iterator.
     *
     * Note this means that, given an array of two datasets that produce dict
     * elements, the result is a dataset that produces elements that are arrays
     * of two dicts:
     *
     * Zip an array of datasets:
     * ```js
     * console.log('Zip two datasets of objects:');
     * const ds1 = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);
     * const ds2 = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);
     * const ds3 = tf.data.zip([ds1, ds2]);
     * await ds3.forEachAsync(e => console.log(JSON.stringify(e)));
     *
     * // If the goal is to merge the dicts in order to produce elements like
     * // {a: ..., b: ...}, this requires a second step such as:
     * console.log('Merge the objects:');
     * const ds4 = ds3.map(x => {return {a: x[0].a, b: x[1].b}});
     * await ds4.forEachAsync(e => console.log(e));
     * ```
     *
     * Zip a dict of datasets:
     * ```js
     * const a = tf.data.array([{a: 1}, {a: 2}, {a: 3}]);
     * const b = tf.data.array([{b: 4}, {b: 5}, {b: 6}]);
     * const c = tf.data.zip({c: a, d: b});
     * await c.forEachAsync(e => console.log(JSON.stringify(e)));
     * ```
     */
    /** @doc {heading: 'Data', subheading: 'Operations', namespace: 'data'} */
    function zip(datasets) {
        var _this = this;
        // manually type-check the argument for JS users
        if (!isIterable(datasets)) {
            throw new Error('The argument to zip() must be an object or array.');
        }
        var size;
        if (Array.isArray(datasets)) {
            for (var i = 0; i < datasets.length; i++) {
                size = size == null ? datasets[i].size :
                    Math.min(size, datasets[i].size);
            }
        }
        else if (datasets instanceof Object) {
            for (var ds in datasets) {
                size = size == null ? datasets[ds].size :
                    Math.min(size, datasets[ds].size);
            }
        }
        return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () {
            var streams;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, deepMapAndAwaitAll(datasets, function (d) {
                            if (d instanceof Dataset) {
                                return { value: d.iterator(), recurse: false };
                            }
                            else if (isIterable(d)) {
                                return { value: null, recurse: true };
                            }
                            else {
                                throw new Error('Leaves of the structure passed to zip() must be Datasets, ' +
                                    'not primitives.');
                            }
                        })];
                    case 1:
                        streams = _a.sent();
                        return [2 /*return*/, iteratorFromZipped(streams, ZipMismatchMode.SHORTEST)];
                }
            });
        }); }, size);
    }
    /**
     * A zip function for use with deepZip, passed via the columnMajorBatch call.
     *
     * Accepts an array of identically-structured nested elements and either batches
     * them (if they are primitives, numeric arrays, or Tensors) or requests
     * recursion (if not).
     */
    // tslint:disable-next-line:no-any
    function deepBatchConcat(rows) {
        if (rows === null) {
            return null;
        }
        // use the first item to decide whether to recurse or batch here.
        var exampleRow = rows[0];
        if (canTensorify(exampleRow)) {
            // rows is an array of primitives, Tensors, or arrays.  Batch them.
            var value = batchConcat(rows);
            return { value: value, recurse: false };
        }
        // the example row is an object, so recurse into it.
        return { value: null, recurse: true };
    }
    /**
     * Assembles a list of same-shaped numbers, number arrays, or Tensors
     * into a single new Tensor where axis 0 is the batch dimension.
     */
    function batchConcat(arrays) {
        if (arrays.length === 0) {
            // We can't return an empty Tensor because we don't know the element shape.
            throw new Error('Can\'t make a batch of zero elements.');
        }
        if (arrays[0] instanceof tf.Tensor) {
            // Input is an array of Tensors
            return tf.stack(arrays);
        }
        else {
            // Input is a possibly-nested array of numbers.
            return tf.tensor(arrays);
        }
    }

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /**
     * Represents a potentially large collection of text lines.
     *
     * The results are not batched.
     */
    var TextLineDataset = /** @class */ (function (_super) {
        __extends(TextLineDataset, _super);
        /**
         * Create a `TextLineDataset`.
         *
         * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.
         */
        function TextLineDataset(input) {
            var _this = _super.call(this) || this;
            _this.input = input;
            return _this;
        }
        TextLineDataset.prototype.iterator = function () {
            return __awaiter(this, void 0, void 0, function () {
                var inputIterator, utf8Iterator, lineIterator;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.input.iterator()];
                        case 1:
                            inputIterator = _a.sent();
                            utf8Iterator = inputIterator.decodeUTF8();
                            lineIterator = utf8Iterator.split('\n');
                            return [2 /*return*/, lineIterator];
                    }
                });
            });
        };
        return TextLineDataset;
    }(Dataset));

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    var CODE_QUOTE = '"';
    var STATE_OUT = Symbol('out');
    var STATE_FIELD = Symbol('field');
    var STATE_QUOTE = Symbol('quote');
    var STATE_QUOTE_AFTER_QUOTE = Symbol('quoteafterquote');
    var STATE_WITHIN_QUOTE_IN_QUOTE = Symbol('quoteinquote');
    /**
     * Represents a potentially large collection of delimited text records.
     *
     * The produced `DataElement`s each contain one key-value pair for
     * every column of the table.  When a field is empty in the incoming data, the
     * resulting value is `undefined`, or throw error if it is required.  Values
     * that can be parsed as numbers are emitted as type `number`, other values
     * are parsed as `string`.
     *
     * The results are not batched.
     */
    /** @doc {heading: 'Data', subheading: 'Classes', namespace: 'data'} */
    var CSVDataset = /** @class */ (function (_super) {
        __extends(CSVDataset, _super);
        /**
         * Create a `CSVDataset`.
         *
         * @param input A `DataSource` providing a chunked, UTF8-encoded byte stream.
         * @param csvConfig (Optional) A CSVConfig object that contains configurations
         *     of reading and decoding from CSV file(s).
         *
         *     hasHeader: (Optional) A boolean value that indicates whether the first
         *     row of provided CSV file is a header line with column names, and should
         *     not be included in the data. Defaults to `true`.
         *
         *     columnNames: (Optional) A list of strings that corresponds to
         *     the CSV column names, in order. If provided, it ignores the column
         *     names inferred from the header row. If not provided, infers the column
         *     names from the first row of the records. If hasHeader is false and
         *     columnNames is not provided, this method throws an error.
         *
         *     columnConfigs: (Optional) A dictionary whose key is column names, value
         *     is an object stating if this column is required, column's data type,
         *     default value, and if this column is label. If provided, keys must
         *     correspond to names provided in columnNames or inferred from the file
         *     header lines. If isLabel is true any column, returns an array of two
         *     items: the first item is a dict of features key/value pairs, the second
         *     item is a dict of labels key/value pairs. If no feature is marked as
         *     label, returns a dict of features only.
         *
         *     configuredColumnsOnly (Optional) If true, only columns provided in
         *     columnConfigs will be parsed and provided during iteration.
         *
         *     delimiter (Optional) The string used to parse each line of the input
         *     file. Defaults to `,`.
         */
        function CSVDataset(input, csvConfig) {
            var _this = _super.call(this) || this;
            _this.input = input;
            _this.hasHeader = true;
            _this.fullColumnNames = null;
            _this.columnNamesValidated = false;
            _this.columnConfigs = null;
            _this.configuredColumnsOnly = false;
            _this.delimiter = ',';
            _this.base = new TextLineDataset(input);
            if (!csvConfig) {
                csvConfig = {};
            }
            _this.hasHeader = csvConfig.hasHeader === false ? false : true;
            _this.fullColumnNames = csvConfig.columnNames;
            _this.columnConfigs = csvConfig.columnConfigs;
            _this.configuredColumnsOnly = csvConfig.configuredColumnsOnly;
            _this.delimiter = csvConfig.delimiter ? csvConfig.delimiter : ',';
            return _this;
        }
        /**
         * Returns column names of the csv dataset. If `configuredColumnsOnly` is
         * true, return column names in `columnConfigs`. If `configuredColumnsOnly` is
         * false and `columnNames` is provided, `columnNames`. If
         * `configuredColumnsOnly` is false and `columnNames` is not provided, return
         * all column names parsed from the csv file. For example usage please go to
         * `tf.data.csv`.
         */
        /** @doc {heading: 'Data', subheading: 'Classes'} */
        CSVDataset.prototype.columnNames = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!!this.columnNamesValidated) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.setColumnNames()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2: return [2 /*return*/, this.configuredColumnsOnly ? Object.keys(this.columnConfigs) :
                                this.fullColumnNames];
                    }
                });
            });
        };
        /* 1) If `columnNames` is provided as string[], use this string[] as output
         * keys in corresponding order. The length must match the number of inferred
         * columns if `hasHeader` is true .
         * 2) If `columnNames` is not provided, parse header line as `columnNames` if
         * hasHeader is true. If `hasHeader` is false, throw an error.
         * 3) If `columnConfigs` is provided, all the keys in `columnConfigs` must
         * exist in parsed `columnNames`.
         */
        CSVDataset.prototype.setColumnNames = function () {
            return __awaiter(this, void 0, void 0, function () {
                var columnNamesFromFile, counts, duplicateNames, _i, _a, key, index;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.maybeReadHeaderLine()];
                        case 1:
                            columnNamesFromFile = _b.sent();
                            if (!this.fullColumnNames && !columnNamesFromFile) {
                                // Throw an error if columnNames is not provided and no header line.
                                throw new Error('Column names must be provided if there is no header line.');
                            }
                            else if (this.fullColumnNames && columnNamesFromFile) {
                                // Check provided columnNames match header line.
                                tf.util.assert(columnNamesFromFile.length === this.fullColumnNames.length, function () { return 'The length of provided columnNames (' +
                                    _this.fullColumnNames.length.toString() +
                                    ') does not match the length of the header line read from ' +
                                    'file (' + columnNamesFromFile.length.toString() + ').'; });
                            }
                            if (!this.fullColumnNames) {
                                this.fullColumnNames = columnNamesFromFile;
                            }
                            counts = this.fullColumnNames.reduce(function (countAcc, name) {
                                countAcc[name] = (countAcc[name] + 1) || 1;
                                return countAcc;
                            }, {});
                            duplicateNames = Object.keys(counts).filter(function (name) { return (counts[name] > 1); });
                            tf.util.assert(duplicateNames.length === 0, function () { return 'Duplicate column names found: ' + duplicateNames.toString(); });
                            // Check if keys in columnConfigs match columnNames.
                            if (this.columnConfigs) {
                                for (_i = 0, _a = Object.keys(this.columnConfigs); _i < _a.length; _i++) {
                                    key = _a[_i];
                                    index = this.fullColumnNames.indexOf(key);
                                    if (index === -1) {
                                        throw new Error('The key "' + key +
                                            '" provided in columnConfigs does not match any of the column ' +
                                            'names (' + this.fullColumnNames.toString() + ').');
                                    }
                                }
                            }
                            this.columnNamesValidated = true;
                            return [2 /*return*/];
                    }
                });
            });
        };
        CSVDataset.prototype.maybeReadHeaderLine = function () {
            return __awaiter(this, void 0, void 0, function () {
                var iter, firstElement, firstLine;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!this.hasHeader) return [3 /*break*/, 3];
                            return [4 /*yield*/, this.base.iterator()];
                        case 1:
                            iter = _a.sent();
                            return [4 /*yield*/, iter.next()];
                        case 2:
                            firstElement = _a.sent();
                            if (firstElement.done) {
                                throw new Error('No data was found for CSV parsing.');
                            }
                            firstLine = firstElement.value;
                            return [2 /*return*/, firstLine.split(this.delimiter)];
                        case 3: return [2 /*return*/, null];
                    }
                });
            });
        };
        CSVDataset.prototype.iterator = function () {
            return __awaiter(this, void 0, void 0, function () {
                var lines;
                var _this = this;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            if (!!this.columnNamesValidated) return [3 /*break*/, 2];
                            return [4 /*yield*/, this.setColumnNames()];
                        case 1:
                            _a.sent();
                            _a.label = 2;
                        case 2: return [4 /*yield*/, this.base.iterator()];
                        case 3:
                            lines = _a.sent();
                            if (this.hasHeader) {
                                // We previously read the first line to get the columnNames.
                                // Now that we're providing data, skip it.
                                lines = lines.skip(1);
                            }
                            return [2 /*return*/, lines.map(function (x) { return _this.makeDataElement(x); })];
                    }
                });
            });
        };
        CSVDataset.prototype.makeDataElement = function (line) {
            var values = this.parseRow(line);
            var features = {};
            var labels = {};
            for (var i = 0; i < this.fullColumnNames.length; i++) {
                var key = this.fullColumnNames[i];
                var config = this.columnConfigs ? this.columnConfigs[key] : null;
                if (this.configuredColumnsOnly && !config) {
                    // This column is not selected.
                    continue;
                }
                else {
                    var value = values[i];
                    var parsedValue = null;
                    if (value === '') {
                        // If default value is provided, use it. If default value is not
                        // provided, set as undefined.
                        if (config && config.default !== undefined) {
                            parsedValue = config.default;
                        }
                        else if (config && (config.required || config.isLabel)) {
                            throw new Error("Required column " + key + " is empty in this line: " + line);
                        }
                        else {
                            parsedValue = undefined;
                        }
                    }
                    else {
                        // A value is present, so parse it based on type
                        var valueAsNum = Number(value);
                        if (isNaN(valueAsNum)) {
                            // The value is a string and this column is declared as boolean
                            // in config, parse it as boolean.
                            if (config && config.dtype === 'bool') {
                                parsedValue = this.getBoolean(value);
                            }
                            else {
                                // Set value as string
                                parsedValue = value;
                            }
                        }
                        else if (!config || !config.dtype) {
                            // If this value is a number and no type config is provided, return
                            // it as number.
                            parsedValue = valueAsNum;
                        }
                        else {
                            // If this value is a number and data type is provided, parse it
                            // according to provided data type.
                            switch (config.dtype) {
                                case 'float32':
                                    parsedValue = valueAsNum;
                                    break;
                                case 'int32':
                                    parsedValue = Math.floor(valueAsNum);
                                    break;
                                case 'bool':
                                    parsedValue = this.getBoolean(value);
                                    break;
                                default:
                                    parsedValue = valueAsNum;
                            }
                        }
                    }
                    // Check if this column is label.
                    (config && config.isLabel) ? labels[key] = parsedValue :
                        features[key] = parsedValue;
                }
            }
            // If label exists, return an array of features and labels, otherwise
            // return features only.
            if (Object.keys(labels).length === 0) {
                return features;
            }
            else {
                return { xs: features, ys: labels };
            }
        };
        CSVDataset.prototype.getBoolean = function (value) {
            if (value === '1' || value.toLowerCase() === 'true') {
                return 1;
            }
            else {
                return 0;
            }
        };
        // adapted from https://beta.observablehq.com/@mbostock/streaming-csv
        CSVDataset.prototype.parseRow = function (line) {
            var result = [];
            var readOffset = 0;
            var readLength = line.length;
            var currentState = STATE_FIELD;
            // Goes through the line to parse quote.
            for (var i = 0; i < readLength; i++) {
                switch (currentState) {
                    // Before enter a new field
                    case STATE_OUT:
                        switch (line.charAt(i)) {
                            // Enter a quoted field
                            case CODE_QUOTE:
                                readOffset = i + 1;
                                currentState = STATE_QUOTE;
                                break;
                            // Read an empty field
                            case this.delimiter:
                                result.push('');
                                currentState = STATE_OUT;
                                readOffset = i + 1;
                                break;
                            // Enter an unquoted field
                            default:
                                currentState = STATE_FIELD;
                                readOffset = i;
                                break;
                        }
                        break;
                    // In an unquoted field
                    case STATE_FIELD:
                        switch (line.charAt(i)) {
                            // Exit an unquoted field, add it to result
                            case this.delimiter:
                                result.push(line.substring(readOffset, i));
                                currentState = STATE_OUT;
                                readOffset = i + 1;
                                break;
                            default:
                        }
                        break;
                    // In a quoted field
                    case STATE_QUOTE:
                        switch (line.charAt(i)) {
                            // Read a quote after a quote
                            case CODE_QUOTE:
                                currentState = STATE_QUOTE_AFTER_QUOTE;
                                break;
                            default:
                        }
                        break;
                    // This state means it's right after a second quote in a field
                    case STATE_QUOTE_AFTER_QUOTE:
                        switch (line.charAt(i)) {
                            // Finished a quoted field
                            case this.delimiter:
                                result.push(line.substring(readOffset, i - 1));
                                currentState = STATE_OUT;
                                readOffset = i + 1;
                                break;
                            // Finished a quoted part in a quoted field
                            case CODE_QUOTE:
                                currentState = STATE_QUOTE;
                                break;
                            // In a quoted part in a quoted field
                            default:
                                currentState = STATE_WITHIN_QUOTE_IN_QUOTE;
                                break;
                        }
                        break;
                    case STATE_WITHIN_QUOTE_IN_QUOTE:
                        switch (line.charAt(i)) {
                            // Exit a quoted part in a quoted field
                            case CODE_QUOTE:
                                currentState = STATE_QUOTE;
                                break;
                            default:
                        }
                        break;
                    default:
                }
            }
            // Adds last item based on if it is quoted.
            if (currentState === STATE_QUOTE_AFTER_QUOTE) {
                result.push(line.substring(readOffset, readLength - 1));
            }
            else {
                result.push(line.substring(readOffset));
            }
            return result;
        };
        return CSVDataset;
    }(Dataset));
    // TODO(soergel): add more basic datasets for parity with tf.data
    // tf.data.FixedLengthRecordDataset()
    // tf.data.TFRecordDataset()

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /**
     * Represents a data source readable as a stream of binary data chunks.
     *
     * Because `Dataset`s can be read repeatedly (via `Dataset.iterator()`), this
     * provides a means to repeatedly create streams from the underlying data
     * sources.
     */
    var DataSource = /** @class */ (function () {
        function DataSource() {
        }
        return DataSource;
    }());
    // TODO(soergel): consider convenience factory functions here
    // in combination with chainable source->dataset above, e.g.:
    // tf.data.url(...).asCsvDataset().shuffle().batch()

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    var StringIterator = /** @class */ (function (_super) {
        __extends(StringIterator, _super);
        function StringIterator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Splits a string stream on a given separator.
         *
         * It is assumed that the incoming chunk boundaries have no semantic meaning,
         * so conceptually the incoming stream is treated simply as the concatenation
         * of its elements.
         *
         * The outgoing stream provides chunks corresponding to the results of the
         * standard string split() operation (even if such a chunk spanned incoming
         * chunks).  The separators are not included.
         *
         * A typical usage is to split a text file (represented as a stream with
         * arbitrary chunk boundaries) into lines.
         *
         * @param upstream A readable stream of strings that can be treated as
         *   concatenated.
         * @param separator A character to split on.
         */
        StringIterator.prototype.split = function (separator) {
            return new SplitIterator(this, separator);
        };
        return StringIterator;
    }(LazyIterator));
    // ============================================================================
    // The following private classes serve to implement the chainable methods
    // on StringIterator.  Unfortunately they can't be placed in separate files, due
    // to resulting trouble with circular imports.
    // ============================================================================
    // We wanted multiple inheritance, e.g.
    //   class SplitIterator extends QueueIterator<string>, StringIterator
    // but the TypeScript mixin approach is a bit hacky, so we take this adapter
    // approach instead.
    var SplitIterator = /** @class */ (function (_super) {
        __extends(SplitIterator, _super);
        function SplitIterator(upstream, separator) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.impl = new SplitIteratorImpl(upstream, separator);
            return _this;
        }
        SplitIterator.prototype.summary = function () {
            return this.impl.summary();
        };
        SplitIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.impl.next()];
                });
            });
        };
        return SplitIterator;
    }(StringIterator));
    var SplitIteratorImpl = /** @class */ (function (_super) {
        __extends(SplitIteratorImpl, _super);
        function SplitIteratorImpl(upstream, separator) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.separator = separator;
            // A partial string at the end of an upstream chunk
            _this.carryover = '';
            return _this;
        }
        SplitIteratorImpl.prototype.summary = function () {
            return this.upstream.summary() + " -> Split('" + this.separator + "')";
        };
        SplitIteratorImpl.prototype.pump = function () {
            return __awaiter(this, void 0, void 0, function () {
                var chunkResult, lines, _i, _a, line;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0: return [4 /*yield*/, this.upstream.next()];
                        case 1:
                            chunkResult = _b.sent();
                            if (chunkResult.done) {
                                if (this.carryover === '') {
                                    return [2 /*return*/, false];
                                }
                                // Pretend that the pump succeeded in order to emit the small last batch.
                                // The next pump() call will actually fail.
                                this.outputQueue.push(this.carryover);
                                this.carryover = '';
                                return [2 /*return*/, true];
                            }
                            lines = chunkResult.value.split(this.separator);
                            // Note the behavior: " ab ".split(' ') === ['', 'ab', '']
                            // Thus the carryover may be '' if the separator falls on a chunk
                            // boundary; this produces the correct result.
                            lines[0] = this.carryover + lines[0];
                            for (_i = 0, _a = lines.slice(0, -1); _i < _a.length; _i++) {
                                line = _a[_i];
                                this.outputQueue.push(line);
                            }
                            this.carryover = lines[lines.length - 1];
                            return [2 /*return*/, true];
                    }
                });
            });
        };
        return SplitIteratorImpl;
    }(OneToManyIterator));

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    var ByteChunkIterator = /** @class */ (function (_super) {
        __extends(ByteChunkIterator, _super);
        function ByteChunkIterator() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        /**
         * Decode a stream of UTF8-encoded byte arrays to a stream of strings.
         *
         * The byte arrays producetd from the ByteChunkIterator on which this is
         * called will be interpreted as concatenated.  No assumptions are made about
         * the boundaries of the incoming chunks, so a multi-byte UTF8 encoding of a
         * character may span the boundary between chunks.  This naturally happens,
         * for instance, when reading fixed-size byte arrays from a file.
         */
        ByteChunkIterator.prototype.decodeUTF8 = function () {
            return new Utf8Iterator(this);
        };
        return ByteChunkIterator;
    }(LazyIterator));
    // ============================================================================
    // The following private classes serve to implement the chainable methods
    // on ByteChunkIterator.  Unfortunately they can't be placed in separate files,
    // due to resulting trouble with circular imports.
    // ============================================================================
    // We wanted multiple inheritance, e.g.
    //   class Utf8Iterator extends QueueIterator<string>, StringIterator
    // but the TypeScript mixin approach is a bit hacky, so we take this adapter
    // approach instead.
    var Utf8Iterator = /** @class */ (function (_super) {
        __extends(Utf8Iterator, _super);
        function Utf8Iterator(upstream) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            _this.impl = new Utf8IteratorImpl(upstream);
            return _this;
        }
        Utf8Iterator.prototype.summary = function () {
            return this.impl.summary();
        };
        Utf8Iterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    return [2 /*return*/, this.impl.next()];
                });
            });
        };
        return Utf8Iterator;
    }(StringIterator));
    /**
     * Decode a stream of UTF8-encoded byte arrays to a stream of strings.
     *
     * This is tricky because the incoming byte array boundaries may disrupt a
     * multi-byte UTF8 character. Thus any incomplete character data at the end of
     * a chunk must be carried over and prepended to the next chunk before
     * decoding. Luckily with native decoder, TextDecoder in browser and
     * string_decoder in node, byte array boundaries are handled automatically.
     *
     * In the context of an input pipeline for machine learning, UTF8 decoding is
     * needed to parse text files containing training examples or prediction
     * requests (e.g., formatted as CSV or JSON). We cannot use the built-in
     * decoding provided by FileReader.readAsText() because here we are in a
     * streaming context, which FileReader does not support.
     *
     * @param upstream A `LazyIterator` of `Uint8Arrays` containing UTF8-encoded
     *   text, which should be interpreted as concatenated.  No assumptions are
     *   made about the boundaries of the incoming chunks, so a multi-byte UTF8
     *   encoding of a character may span the boundary between chunks.  This
     *   naturally happens, for instance, when reading fixed-size byte arrays from a
     *   file.
     */
    var Utf8IteratorImpl = /** @class */ (function (_super) {
        __extends(Utf8IteratorImpl, _super);
        function Utf8IteratorImpl(upstream) {
            var _this = _super.call(this) || this;
            _this.upstream = upstream;
            if (tf.ENV.get('IS_BROWSER')) {
                _this.decoder = new TextDecoder('utf-8');
            }
            else {
                // tslint:disable-next-line:no-require-imports
                var StringDecoder = require('string_decoder').StringDecoder;
                _this.decoder = new StringDecoder('utf8');
            }
            return _this;
        }
        Utf8IteratorImpl.prototype.summary = function () {
            return this.upstream.summary() + " -> Utf8";
        };
        Utf8IteratorImpl.prototype.pump = function () {
            return __awaiter(this, void 0, void 0, function () {
                var chunkResult, chunk, text;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, this.upstream.next()];
                        case 1:
                            chunkResult = _a.sent();
                            if (chunkResult.done) {
                                return [2 /*return*/, false];
                            }
                            else {
                                chunk = chunkResult.value;
                            }
                            if (tf.ENV.get('IS_BROWSER')) {
                                text = this.decoder.decode(chunk, { stream: true });
                            }
                            else {
                                text = this.decoder.write(Buffer.from(chunk.buffer));
                            }
                            this.outputQueue.push(text);
                            return [2 /*return*/, true];
                    }
                });
            });
        };
        return Utf8IteratorImpl;
    }(OneToManyIterator));

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /**
     * Provide a stream of chunks from a File, Blob, or Uint8Array.
     * @param file The source File, Blob or Uint8Array.
     * @param options Optional settings controlling file reading.
     * @returns a lazy Iterator of Uint8Arrays containing sequential chunks of the
     *   input File, Blob or Uint8Array.
     */
    var FileChunkIterator = /** @class */ (function (_super) {
        __extends(FileChunkIterator, _super);
        function FileChunkIterator(file, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this.file = file;
            _this.options = options;
            tf.util.assert((file instanceof Uint8Array) ||
                (tf.ENV.get('IS_BROWSER') ?
                    (file instanceof File || file instanceof Blob) :
                    false), function () { return 'FileChunkIterator only supports File, Blob and Uint8Array ' +
                'right now.'; });
            _this.offset = options.offset || 0;
            // default 1MB chunk has tolerable perf on large files
            _this.chunkSize = options.chunkSize || 1024 * 1024;
            return _this;
        }
        FileChunkIterator.prototype.summary = function () {
            return "FileChunks " + this.file;
        };
        FileChunkIterator.prototype.next = function () {
            return __awaiter(this, void 0, void 0, function () {
                var chunk, _a;
                var _this = this;
                return __generator(this, function (_b) {
                    switch (_b.label) {
                        case 0:
                            if (this.offset >= ((this.file instanceof Uint8Array) ?
                                this.file.byteLength :
                                this.file.size)) {
                                return [2 /*return*/, { value: null, done: true }];
                            }
                            chunk = new Promise(function (resolve, reject) {
                                var end = _this.offset + _this.chunkSize;
                                if (_this.file instanceof Uint8Array) {
                                    // Note if end > this.uint8Array.byteLength, we just get a small last
                                    // chunk.
                                    resolve(new Uint8Array(_this.file.slice(_this.offset, end)));
                                }
                                else {
                                    // This branch assumes that this.file type is File or Blob, which
                                    // means it is in the browser environment.
                                    // TODO(soergel): is this a performance issue?
                                    var fileReader_1 = new FileReader();
                                    fileReader_1.onload = function (event) {
                                        var data = fileReader_1.result;
                                        // Not sure we can trust the return type of
                                        // FileReader.readAsArrayBuffer See e.g.
                                        // https://github.com/node-file-api/FileReader/issues/2
                                        if (data instanceof ArrayBuffer) {
                                            data = new Uint8Array(data);
                                        }
                                        if (!(data instanceof Uint8Array)) {
                                            return reject(new TypeError('FileReader returned unknown type.'));
                                        }
                                        resolve(data);
                                    };
                                    fileReader_1.onabort = function (event) {
                                        return reject(new Error('Aborted'));
                                    };
                                    fileReader_1.onerror = function (event) {
                                        return reject(new Error(event.type));
                                    };
                                    // TODO(soergel): better handle onabort, onerror
                                    // Note if end > this.file.size, we just get a small last chunk.
                                    var slice = _this.file.slice(_this.offset, end);
                                    // We can't use readAsText here (even if we know the file is text)
                                    // because the slice boundary may fall within a multi-byte character.
                                    fileReader_1.readAsArrayBuffer(slice);
                                }
                                _this.offset = end;
                            });
                            _a = {};
                            return [4 /*yield*/, chunk];
                        case 1: return [2 /*return*/, (_a.value = (_b.sent()), _a.done = false, _a)];
                    }
                });
            });
        };
        return FileChunkIterator;
    }(ByteChunkIterator));

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /**
     * Provide a stream of chunks from a URL.
     *
     * Note this class first downloads the entire file into memory before providing
     * the first element from the stream.  This is because the Fetch API does not
     * yet reliably provide a reader stream for the response body.
     */
    function urlChunkIterator(url, options) {
        if (options === void 0) { options = {}; }
        return __awaiter(this, void 0, void 0, function () {
            var response, blob, nodeFetch, unitArray;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        if (!tf.ENV.get('IS_BROWSER')) return [3 /*break*/, 5];
                        return [4 /*yield*/, fetch(url)];
                    case 1:
                        response = _a.sent();
                        if (!response.ok) return [3 /*break*/, 3];
                        return [4 /*yield*/, response.blob()];
                    case 2:
                        blob = _a.sent();
                        return [2 /*return*/, new FileChunkIterator(blob, options)];
                    case 3: throw new Error(response.statusText);
                    case 4: return [3 /*break*/, 9];
                    case 5:
                        nodeFetch = require('node-fetch');
                        if (typeof url !== 'string') {
                            throw new Error('URL must be a string. Request objects are not supported ' +
                                'in the node.js environment yet.');
                        }
                        return [4 /*yield*/, nodeFetch(url)];
                    case 6:
                        response = _a.sent();
                        if (!response.ok) return [3 /*break*/, 8];
                        return [4 /*yield*/, response.buffer()];
                    case 7:
                        unitArray = _a.sent();
                        return [2 /*return*/, new FileChunkIterator(unitArray, options)];
                    case 8: throw new Error(response.statusText);
                    case 9: return [2 /*return*/];
                }
            });
        });
    }

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    // Skip tslint any type check cause this method is aiming to check type of
    // input.
    // tslint:disable-next-line:no-any
    function isLocalPath(source) {
        return (typeof source === 'string') && source.substr(0, 7) === 'file://';
    }

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /**
     * Represents a file, blob, or Uint8Array readable as a stream of binary data
     * chunks.
     */
    var FileDataSource = /** @class */ (function (_super) {
        __extends(FileDataSource, _super);
        /**
         * Create a `FileDataSource`.
         *
         * @param input Local file path, or `File`/`Blob`/`Uint8Array` object to
         *     read. Local file only works in node environment.
         * @param options Options passed to the underlying `FileChunkIterator`s,
         *   such as {chunksize: 1024}.
         */
        function FileDataSource(input, options) {
            if (options === void 0) { options = {}; }
            var _this = _super.call(this) || this;
            _this.input = input;
            _this.options = options;
            return _this;
        }
        FileDataSource.prototype.iterator = function () {
            return __awaiter(this, void 0, void 0, function () {
                var fs;
                return __generator(this, function (_a) {
                    if (isLocalPath(this.input) && tf.ENV.get('IS_NODE')) {
                        fs = require('fs');
                        this.input = fs.readFileSync(this.input.substr(7));
                    }
                    // TODO(kangyizhang): Add LocalFileChunkIterator to split local streaming
                    // with file in browser.
                    return [2 /*return*/, new FileChunkIterator(this.input, this.options)];
                });
            });
        };
        return FileDataSource;
    }(DataSource));

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /*
     * Represents a URL readable as a stream of binary data chunks.
     */
    var URLDataSource = /** @class */ (function (_super) {
        __extends(URLDataSource, _super);
        /**
         * Create a `URLDataSource`.
         *
         * @param url A source URL string, or a `Request` object.
         * @param options Options passed to the underlying `FileChunkIterator`s,
         *   such as {chunksize: 1024}.
         */
        function URLDataSource(url, fileOptions) {
            if (fileOptions === void 0) { fileOptions = {}; }
            var _this = _super.call(this) || this;
            _this.url = url;
            _this.fileOptions = fileOptions;
            return _this;
        }
        // TODO(soergel): provide appropriate caching options.  Currently this
        // will download the URL anew for each call to iterator().  Since we have
        // to treat the downloaded file as a blob/buffer anyway, we may as well retain
        // it-- but that raises GC issues.  Also we may want a persistent disk cache.
        URLDataSource.prototype.iterator = function () {
            return __awaiter(this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    if (isLocalPath(this.url)) {
                        return [2 /*return*/, (new FileDataSource(this.url, this.fileOptions))
                                .iterator()];
                    }
                    else {
                        return [2 /*return*/, urlChunkIterator(this.url, this.fileOptions)];
                    }
                    return [2 /*return*/];
                });
            });
        };
        return URLDataSource;
    }(DataSource));

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     *
     * =============================================================================
     */
    /**
     * Create a `CSVDataset` by reading and decoding CSV file(s) from provided URL
     * or local path if it's in Node environment.
     *
     * ```js
     * const csvUrl =
     * 'https://storage.googleapis.com/tfjs-examples/multivariate-linear-regression/data/boston-housing-train.csv';
     *
     * async function run() {
     *   // We want to predict the column "medv", which represents a median value of
     *   // a home (in $1000s), so we mark it as a label.
     *   const csvDataset = tf.data.csv(
     *     csvUrl, {
     *       columnConfigs: {
     *         medv: {
     *           isLabel: true
     *         }
     *       }
     *     });
     *
     *   // Number of features is the number of column names minus one for the label
     *   // column.
     *   const numOfFeatures = (await csvDataset.columnNames()).length - 1;
     *
     *   // Prepare the Dataset for training.
     *   const flattenedDataset =
     *     csvDataset
     *     .map(({xs, ys}) =>
     *       {
     *         // Convert rows from object form (keyed by column name) to array
     *         // form.
     *         return {xs:Object.values(xs), ys:Object.values(ys)};
     *       })
     *     .batch(10);
     *
     *   // Define the model.
     *   const model = tf.sequential();
     *   model.add(tf.layers.dense({
     *     inputShape: [numOfFeatures],
     *     units: 1
     *   }));
     *   model.compile({
     *     optimizer: tf.train.sgd(0.000001),
     *     loss: 'meanSquaredError'
     *   });
     *
     *   // Fit the model using the prepared Dataset
     *   return model.fitDataset(flattenedDataset, {
     *     epochs: 10,
     *     callbacks: {
     *       onEpochEnd: async (epoch, logs) => {
     *         console.log(epoch + ':' + logs.loss);
     *       }
     *     }
     *   });
     * }
     *
     * await run();
     * ```
     *
     * @param source URL or local path to get CSV file. If it's a local path, it
     * must have prefix `file://` and it only works in node environment.
     * @param csvConfig (Optional) A CSVConfig object that contains configurations
     *     of reading and decoding from CSV file(s).
     */
    /**
     * @doc {
     *   heading: 'Data',
     *   subheading: 'Creation',
     *   namespace: 'data',
     *   configParamIndices: [1]
     *  }
     */
    function csv(source, csvConfig) {
        if (csvConfig === void 0) { csvConfig = {}; }
        return new CSVDataset(new URLDataSource(source), csvConfig);
    }
    /**
     * Create a `Dataset` that produces each element by calling a provided function.
     *
     * Note that repeated iterations over this `Dataset` may produce different
     * results, because the function will be called anew for each element of each
     * iteration.
     *
     * Also, beware that the sequence of calls to this function may be out of order
     * in time with respect to the logical order of the Dataset. This is due to the
     * asynchronous lazy nature of stream processing, and depends on downstream
     * transformations (e.g. .shuffle()). If the provided function is pure, this is
     * no problem, but if it is a closure over a mutable state (e.g., a traversal
     * pointer), then the order of the produced elements may be scrambled.
     *
     * ```js
     * let i = -1;
     * const func = () =>
     *    ++i < 5 ? {value: i, done: false} : {value: null, done: true};
     * const ds = tf.data.func(func);
     * await ds.forEachAsync(e => console.log(e));
     * ```
     *
     * @param f A function that produces one data element on each call.
     */
    function func(f) {
        var _this = this;
        var iter = iteratorFromFunction(f);
        return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () { return __generator(this, function (_a) {
            return [2 /*return*/, iter];
        }); }); });
    }
    /**
     * Create a `Dataset` that produces each element from provided JavaScript
     * generator, which is a function*
     * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Generator_functions),
     * or a function that returns an
     * iterator
     * (https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators#Generator_functions).
     *
     * The returned iterator should have `.next()` function that returns element in
     * format of `{value: DataElement, done:boolean}`.
     *
     * Example of creating a dataset from an iterator factory:
     * ```js
     * function makeIterator() {
     *   const numElements = 10;
     *   let index = 0;
     *
     *   const iterator = {
     *     next: () => {
     *       let result;
     *       if (index < numElements) {
     *         result = {value: index, done: false};
     *         index++;
     *         return result;
     *       }
     *       return {value: index, done: true};
     *     }
     *   };
     *   return iterator;
     * }
     * const ds = tf.data.generator(makeIterator);
     * ds.forEachAsync(e => console.log(e));
     * ```
     *
     * Example of creating a dataset from a generator:
     * ```js
     * function* dataGenerator() {
     *   const numElements = 10;
     *   let index = 0;
     *   while (index < numElements) {
     *     const x = index;
     *     index++;
     *     yield x;
     *   }
     * }
     *
     * const ds = tf.data.generator(dataGenerator);
     * ds.forEachAsync(e => console.log(e));
     * ```
     *
     * @param generator A Javascript generator function that returns a JavaScript
     *     iterator.
     */
    /**
     * @doc {
     *   heading: 'Data',
     *   subheading: 'Creation',
     *   namespace: 'data',
     *   configParamIndices: [1]
     *  }
     */
    function generator(generator) {
        var _this = this;
        return datasetFromIteratorFn(function () { return __awaiter(_this, void 0, void 0, function () {
            var gen;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0: return [4 /*yield*/, generator()];
                    case 1:
                        gen = _a.sent();
                        return [2 /*return*/, iteratorFromFunction(function () { return gen.next(); })];
                }
            });
        }); });
    }

    /** @license See the LICENSE file. */
    // This code is auto-generated, do not modify this file!
    var version = '1.0.1';

    /**
     * @license
     * Copyright 2018 Google LLC. All Rights Reserved.
     * Licensed under the Apache License, Version 2.0 (the "License");
     * you may not use this file except in compliance with the License.
     * You may obtain a copy of the License at
     *
     * http://www.apache.org/licenses/LICENSE-2.0
     *
     * Unless required by applicable law or agreed to in writing, software
     * distributed under the License is distributed on an "AS IS" BASIS,
     * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
     * See the License for the specific language governing permissions and
     * limitations under the License.
     * =============================================================================
     */

    exports.array = array;
    exports.Dataset = Dataset;
    exports.zip = zip;
    exports.CSVDataset = CSVDataset;
    exports.TextLineDataset = TextLineDataset;
    exports.csv = csv;
    exports.func = func;
    exports.generator = generator;
    exports.FileDataSource = FileDataSource;
    exports.URLDataSource = URLDataSource;
    exports.version_data = version;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=tf-data.js.map
